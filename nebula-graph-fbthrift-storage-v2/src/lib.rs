// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, Debug, PartialEq)]
    pub struct PartitionResult {
        pub code: crate::types::ErrorCode,
        pub part_id: common::types::PartitionID,
        pub leader: ::std::option::Option<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ResponseCommon {
        pub failed_parts: ::std::vec::Vec<crate::types::PartitionResult>,
        pub latency_in_us: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct StatProp {
        pub alias: ::std::vec::Vec<::std::primitive::u8>,
        pub prop: ::std::vec::Vec<::std::primitive::u8>,
        pub stat: crate::types::StatType,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Expr {
        pub alias: ::std::vec::Vec<::std::primitive::u8>,
        pub expr: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct EdgeProp {
        pub type_: common::types::EdgeType,
        pub props: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct VertexProp {
        pub tag: common::types::TagID,
        pub props: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OrderBy {
        pub prop: ::std::vec::Vec<::std::primitive::u8>,
        pub direction: crate::types::OrderDirection,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TraverseSpec {
        pub edge_types: ::std::vec::Vec<common::types::EdgeType>,
        pub edge_direction: crate::types::EdgeDirection,
        pub dedup: ::std::primitive::bool,
        pub stat_props: ::std::option::Option<::std::vec::Vec<crate::types::StatProp>>,
        pub vertex_props: ::std::option::Option<::std::vec::Vec<crate::types::VertexProp>>,
        pub edge_props: ::std::option::Option<::std::vec::Vec<crate::types::EdgeProp>>,
        pub expressions: ::std::option::Option<::std::vec::Vec<crate::types::Expr>>,
        pub order_by: ::std::option::Option<::std::vec::Vec<crate::types::OrderBy>>,
        pub random: ::std::option::Option<::std::primitive::bool>,
        pub limit: ::std::option::Option<::std::primitive::i64>,
        pub filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetNeighborsRequest {
        pub space_id: common::types::GraphSpaceID,
        pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Row>>,
        pub traverse_spec: crate::types::TraverseSpec,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetNeighborsResponse {
        pub result: crate::types::ResponseCommon,
        pub vertices: ::std::option::Option<common::types::DataSet>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ExecResponse {
        pub result: crate::types::ResponseCommon,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetPropRequest {
        pub space_id: common::types::GraphSpaceID,
        pub column_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::Row>>,
        pub vertex_props: ::std::option::Option<::std::vec::Vec<crate::types::VertexProp>>,
        pub edge_props: ::std::option::Option<::std::vec::Vec<crate::types::EdgeProp>>,
        pub expressions: ::std::option::Option<::std::vec::Vec<crate::types::Expr>>,
        pub dedup: ::std::primitive::bool,
        pub order_by: ::std::option::Option<::std::vec::Vec<crate::types::OrderBy>>,
        pub limit: ::std::option::Option<::std::primitive::i64>,
        pub filter: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetPropResponse {
        pub result: crate::types::ResponseCommon,
        pub props: ::std::option::Option<common::types::DataSet>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NewTag {
        pub tag_id: common::types::TagID,
        pub props: ::std::vec::Vec<common::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NewVertex {
        pub id: common::types::VertexID,
        pub tags: ::std::vec::Vec<crate::types::NewTag>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct EdgeKey {
        pub src: common::types::VertexID,
        pub edge_type: common::types::EdgeType,
        pub ranking: common::types::EdgeRanking,
        pub dst: common::types::VertexID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct NewEdge {
        pub key: crate::types::EdgeKey,
        pub props: ::std::vec::Vec<common::types::Value>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddVerticesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::NewVertex>>,
        pub prop_names: ::std::collections::BTreeMap<common::types::TagID, ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
        pub overwritable: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddEdgesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::NewEdge>>,
        pub prop_names: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        pub overwritable: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DeleteVerticesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::VertexID>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DeleteEdgesRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<crate::types::EdgeKey>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateResponse {
        pub result: crate::types::ResponseCommon,
        pub props: ::std::option::Option<common::types::DataSet>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct UpdatedProp {
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        pub value: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateVertexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub vertex_id: common::types::VertexID,
        pub tag_id: common::types::TagID,
        pub updated_props: ::std::vec::Vec<crate::types::UpdatedProp>,
        pub insertable: ::std::option::Option<::std::primitive::bool>,
        pub return_props: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
        pub condition: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct UpdateEdgeRequest {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub edge_key: crate::types::EdgeKey,
        pub updated_props: ::std::vec::Vec<crate::types::UpdatedProp>,
        pub insertable: ::std::option::Option<::std::primitive::bool>,
        pub return_props: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
        pub condition: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetUUIDReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetUUIDResp {
        pub result: crate::types::ResponseCommon,
        pub id: common::types::VertexID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct LookupIndexResp {
        pub result: crate::types::ResponseCommon,
        pub data: ::std::option::Option<common::types::DataSet>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct IndexColumnHint {
        pub column_name: ::std::vec::Vec<::std::primitive::u8>,
        pub scan_type: crate::types::ScanType,
        pub begin_value: common::types::Value,
        pub end_value: common::types::Value,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct IndexQueryContext {
        pub index_id: common::types::IndexID,
        pub filter: ::std::vec::Vec<::std::primitive::u8>,
        pub column_hints: ::std::vec::Vec<crate::types::IndexColumnHint>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct IndexSpec {
        pub contexts: ::std::vec::Vec<crate::types::IndexQueryContext>,
        pub is_edge: ::std::primitive::bool,
        pub tag_or_edge_id: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct LookupIndexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::vec::Vec<common::types::PartitionID>,
        pub indices: crate::types::IndexSpec,
        pub return_columns: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct LookupAndTraverseRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::vec::Vec<common::types::PartitionID>,
        pub indices: crate::types::IndexSpec,
        pub traverse_spec: crate::types::TraverseSpec,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct TaskPara {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::option::Option<::std::vec::Vec<common::types::PartitionID>>,
        pub task_specfic_paras: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddAdminTaskRequest {
        pub cmd: meta::types::AdminCmd,
        pub job_id: ::std::primitive::i32,
        pub task_id: ::std::primitive::i32,
        pub para: crate::types::TaskPara,
        pub concurrency: ::std::option::Option<::std::primitive::i32>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct StopAdminTaskRequest {
        pub job_id: ::std::primitive::i32,
        pub task_id: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AdminExecResp {
        pub result: crate::types::ResponseCommon,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TransLeaderReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub new_leader: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AddPartReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub as_learner: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct AddLearnerReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub learner: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemovePartReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MemberChangeReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub peer: common::types::HostAddr,
        pub add: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CatchUpDataReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub target: common::types::HostAddr,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetLeaderReq {
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CreateCPRequest {
        pub space_id: common::types::GraphSpaceID,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DropCPRequest {
        pub space_id: common::types::GraphSpaceID,
        pub name: ::std::vec::Vec<::std::primitive::u8>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct BlockingSignRequest {
        pub space_id: common::types::GraphSpaceID,
        pub sign: crate::types::EngineSignType,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetLeaderPartsResp {
        pub result: crate::types::ResponseCommon,
        pub leader_parts: ::std::collections::BTreeMap<common::types::GraphSpaceID, ::std::vec::Vec<common::types::PartitionID>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct CheckPeersReq {
        pub space_id: common::types::GraphSpaceID,
        pub part_id: common::types::PartitionID,
        pub peers: ::std::vec::Vec<common::types::HostAddr>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RebuildIndexRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::vec::Vec<common::types::PartitionID>,
        pub index_id: common::types::IndexID,
        pub is_offline: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct KVGetRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
        pub return_partly: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct KVGetResponse {
        pub result: crate::types::ResponseCommon,
        pub key_values: ::std::collections::BTreeMap<::std::vec::Vec<::std::primitive::u8>, ::std::vec::Vec<::std::primitive::u8>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct KVPutRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<common::types::KeyValue>>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct KVRemoveRequest {
        pub space_id: common::types::GraphSpaceID,
        pub parts: ::std::collections::BTreeMap<common::types::PartitionID, ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ErrorCode(pub ::std::primitive::i32);

    impl ErrorCode {
        pub const SUCCEEDED: Self = ErrorCode(0i32);
        pub const E_DISCONNECTED: Self = ErrorCode(-1i32);
        pub const E_FAILED_TO_CONNECT: Self = ErrorCode(-2i32);
        pub const E_RPC_FAILURE: Self = ErrorCode(-3i32);
        pub const E_LEADER_CHANGED: Self = ErrorCode(-11i32);
        pub const E_KEY_HAS_EXISTS: Self = ErrorCode(-12i32);
        pub const E_SPACE_NOT_FOUND: Self = ErrorCode(-13i32);
        pub const E_PART_NOT_FOUND: Self = ErrorCode(-14i32);
        pub const E_KEY_NOT_FOUND: Self = ErrorCode(-15i32);
        pub const E_CONSENSUS_ERROR: Self = ErrorCode(-16i32);
        pub const E_DATA_TYPE_MISMATCH: Self = ErrorCode(-17i32);
        pub const E_INVALID_FIELD_VALUE: Self = ErrorCode(-18i32);
        pub const E_REBUILD_INDEX_FAILED: Self = ErrorCode(-19i32);
        pub const E_INVALID_OPERATION: Self = ErrorCode(-20i32);
        pub const E_NOT_NULLABLE: Self = ErrorCode(-21i32);
        pub const E_FIELD_UNSET: Self = ErrorCode(-22i32);
        pub const E_OUT_OF_RANGE: Self = ErrorCode(-23i32);
        pub const E_ATOMIC_OP_FAILED: Self = ErrorCode(-24i32);
        pub const E_EDGE_PROP_NOT_FOUND: Self = ErrorCode(-31i32);
        pub const E_TAG_PROP_NOT_FOUND: Self = ErrorCode(-32i32);
        pub const E_IMPROPER_DATA_TYPE: Self = ErrorCode(-33i32);
        pub const E_EDGE_NOT_FOUND: Self = ErrorCode(-34i32);
        pub const E_TAG_NOT_FOUND: Self = ErrorCode(-35i32);
        pub const E_INVALID_SPACEVIDLEN: Self = ErrorCode(-36i32);
        pub const E_INDEX_NOT_FOUND: Self = ErrorCode(-37i32);
        pub const E_INVALID_FILTER: Self = ErrorCode(-41i32);
        pub const E_INVALID_UPDATER: Self = ErrorCode(-42i32);
        pub const E_INVALID_STORE: Self = ErrorCode(-43i32);
        pub const E_INVALID_PEER: Self = ErrorCode(-44i32);
        pub const E_RETRY_EXHAUSTED: Self = ErrorCode(-45i32);
        pub const E_TRANSFER_LEADER_FAILED: Self = ErrorCode(-46i32);
        pub const E_INVALID_STAT_TYPE: Self = ErrorCode(-47i32);
        pub const E_INVALID_VID: Self = ErrorCode(-48i32);
        pub const E_LOAD_META_FAILED: Self = ErrorCode(-51i32);
        pub const E_FAILED_TO_CHECKPOINT: Self = ErrorCode(-60i32);
        pub const E_CHECKPOINT_BLOCKED: Self = ErrorCode(-61i32);
        pub const E_PARTIAL_RESULT: Self = ErrorCode(-71i32);
        pub const E_FILTER_OUT: Self = ErrorCode(-81i32);
        pub const E_INVALID_DATA: Self = ErrorCode(-82i32);
        pub const E_INVALID_TASK_PARA: Self = ErrorCode(-90i32);
        pub const E_USER_CANCEL: Self = ErrorCode(-99i32);
        pub const E_UNKNOWN: Self = ErrorCode(-100i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "SUCCEEDED",
                "E_DISCONNECTED",
                "E_FAILED_TO_CONNECT",
                "E_RPC_FAILURE",
                "E_LEADER_CHANGED",
                "E_KEY_HAS_EXISTS",
                "E_SPACE_NOT_FOUND",
                "E_PART_NOT_FOUND",
                "E_KEY_NOT_FOUND",
                "E_CONSENSUS_ERROR",
                "E_DATA_TYPE_MISMATCH",
                "E_INVALID_FIELD_VALUE",
                "E_REBUILD_INDEX_FAILED",
                "E_INVALID_OPERATION",
                "E_NOT_NULLABLE",
                "E_FIELD_UNSET",
                "E_OUT_OF_RANGE",
                "E_ATOMIC_OP_FAILED",
                "E_EDGE_PROP_NOT_FOUND",
                "E_TAG_PROP_NOT_FOUND",
                "E_IMPROPER_DATA_TYPE",
                "E_EDGE_NOT_FOUND",
                "E_TAG_NOT_FOUND",
                "E_INVALID_SPACEVIDLEN",
                "E_INDEX_NOT_FOUND",
                "E_INVALID_FILTER",
                "E_INVALID_UPDATER",
                "E_INVALID_STORE",
                "E_INVALID_PEER",
                "E_RETRY_EXHAUSTED",
                "E_TRANSFER_LEADER_FAILED",
                "E_INVALID_STAT_TYPE",
                "E_INVALID_VID",
                "E_LOAD_META_FAILED",
                "E_FAILED_TO_CHECKPOINT",
                "E_CHECKPOINT_BLOCKED",
                "E_PARTIAL_RESULT",
                "E_FILTER_OUT",
                "E_INVALID_DATA",
                "E_INVALID_TASK_PARA",
                "E_USER_CANCEL",
                "E_UNKNOWN",
            ]
        }
    }

    impl ::std::default::Default for ErrorCode {
        fn default() -> Self {
            ErrorCode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ErrorCode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ErrorCode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ErrorCode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ErrorCode::SUCCEEDED => "SUCCEEDED",
                ErrorCode::E_DISCONNECTED => "E_DISCONNECTED",
                ErrorCode::E_FAILED_TO_CONNECT => "E_FAILED_TO_CONNECT",
                ErrorCode::E_RPC_FAILURE => "E_RPC_FAILURE",
                ErrorCode::E_LEADER_CHANGED => "E_LEADER_CHANGED",
                ErrorCode::E_KEY_HAS_EXISTS => "E_KEY_HAS_EXISTS",
                ErrorCode::E_SPACE_NOT_FOUND => "E_SPACE_NOT_FOUND",
                ErrorCode::E_PART_NOT_FOUND => "E_PART_NOT_FOUND",
                ErrorCode::E_KEY_NOT_FOUND => "E_KEY_NOT_FOUND",
                ErrorCode::E_CONSENSUS_ERROR => "E_CONSENSUS_ERROR",
                ErrorCode::E_DATA_TYPE_MISMATCH => "E_DATA_TYPE_MISMATCH",
                ErrorCode::E_INVALID_FIELD_VALUE => "E_INVALID_FIELD_VALUE",
                ErrorCode::E_REBUILD_INDEX_FAILED => "E_REBUILD_INDEX_FAILED",
                ErrorCode::E_INVALID_OPERATION => "E_INVALID_OPERATION",
                ErrorCode::E_NOT_NULLABLE => "E_NOT_NULLABLE",
                ErrorCode::E_FIELD_UNSET => "E_FIELD_UNSET",
                ErrorCode::E_OUT_OF_RANGE => "E_OUT_OF_RANGE",
                ErrorCode::E_ATOMIC_OP_FAILED => "E_ATOMIC_OP_FAILED",
                ErrorCode::E_EDGE_PROP_NOT_FOUND => "E_EDGE_PROP_NOT_FOUND",
                ErrorCode::E_TAG_PROP_NOT_FOUND => "E_TAG_PROP_NOT_FOUND",
                ErrorCode::E_IMPROPER_DATA_TYPE => "E_IMPROPER_DATA_TYPE",
                ErrorCode::E_EDGE_NOT_FOUND => "E_EDGE_NOT_FOUND",
                ErrorCode::E_TAG_NOT_FOUND => "E_TAG_NOT_FOUND",
                ErrorCode::E_INVALID_SPACEVIDLEN => "E_INVALID_SPACEVIDLEN",
                ErrorCode::E_INDEX_NOT_FOUND => "E_INDEX_NOT_FOUND",
                ErrorCode::E_INVALID_FILTER => "E_INVALID_FILTER",
                ErrorCode::E_INVALID_UPDATER => "E_INVALID_UPDATER",
                ErrorCode::E_INVALID_STORE => "E_INVALID_STORE",
                ErrorCode::E_INVALID_PEER => "E_INVALID_PEER",
                ErrorCode::E_RETRY_EXHAUSTED => "E_RETRY_EXHAUSTED",
                ErrorCode::E_TRANSFER_LEADER_FAILED => "E_TRANSFER_LEADER_FAILED",
                ErrorCode::E_INVALID_STAT_TYPE => "E_INVALID_STAT_TYPE",
                ErrorCode::E_INVALID_VID => "E_INVALID_VID",
                ErrorCode::E_LOAD_META_FAILED => "E_LOAD_META_FAILED",
                ErrorCode::E_FAILED_TO_CHECKPOINT => "E_FAILED_TO_CHECKPOINT",
                ErrorCode::E_CHECKPOINT_BLOCKED => "E_CHECKPOINT_BLOCKED",
                ErrorCode::E_PARTIAL_RESULT => "E_PARTIAL_RESULT",
                ErrorCode::E_FILTER_OUT => "E_FILTER_OUT",
                ErrorCode::E_INVALID_DATA => "E_INVALID_DATA",
                ErrorCode::E_INVALID_TASK_PARA => "E_INVALID_TASK_PARA",
                ErrorCode::E_USER_CANCEL => "E_USER_CANCEL",
                ErrorCode::E_UNKNOWN => "E_UNKNOWN",
                ErrorCode(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ErrorCode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ErrorCode::{}", self)
        }
    }

    impl ::std::str::FromStr for ErrorCode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "SUCCEEDED" => ::std::result::Result::Ok(ErrorCode::SUCCEEDED),
                "E_DISCONNECTED" => ::std::result::Result::Ok(ErrorCode::E_DISCONNECTED),
                "E_FAILED_TO_CONNECT" => ::std::result::Result::Ok(ErrorCode::E_FAILED_TO_CONNECT),
                "E_RPC_FAILURE" => ::std::result::Result::Ok(ErrorCode::E_RPC_FAILURE),
                "E_LEADER_CHANGED" => ::std::result::Result::Ok(ErrorCode::E_LEADER_CHANGED),
                "E_KEY_HAS_EXISTS" => ::std::result::Result::Ok(ErrorCode::E_KEY_HAS_EXISTS),
                "E_SPACE_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_SPACE_NOT_FOUND),
                "E_PART_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_PART_NOT_FOUND),
                "E_KEY_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_KEY_NOT_FOUND),
                "E_CONSENSUS_ERROR" => ::std::result::Result::Ok(ErrorCode::E_CONSENSUS_ERROR),
                "E_DATA_TYPE_MISMATCH" => ::std::result::Result::Ok(ErrorCode::E_DATA_TYPE_MISMATCH),
                "E_INVALID_FIELD_VALUE" => ::std::result::Result::Ok(ErrorCode::E_INVALID_FIELD_VALUE),
                "E_REBUILD_INDEX_FAILED" => ::std::result::Result::Ok(ErrorCode::E_REBUILD_INDEX_FAILED),
                "E_INVALID_OPERATION" => ::std::result::Result::Ok(ErrorCode::E_INVALID_OPERATION),
                "E_NOT_NULLABLE" => ::std::result::Result::Ok(ErrorCode::E_NOT_NULLABLE),
                "E_FIELD_UNSET" => ::std::result::Result::Ok(ErrorCode::E_FIELD_UNSET),
                "E_OUT_OF_RANGE" => ::std::result::Result::Ok(ErrorCode::E_OUT_OF_RANGE),
                "E_ATOMIC_OP_FAILED" => ::std::result::Result::Ok(ErrorCode::E_ATOMIC_OP_FAILED),
                "E_EDGE_PROP_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_EDGE_PROP_NOT_FOUND),
                "E_TAG_PROP_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_TAG_PROP_NOT_FOUND),
                "E_IMPROPER_DATA_TYPE" => ::std::result::Result::Ok(ErrorCode::E_IMPROPER_DATA_TYPE),
                "E_EDGE_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_EDGE_NOT_FOUND),
                "E_TAG_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_TAG_NOT_FOUND),
                "E_INVALID_SPACEVIDLEN" => ::std::result::Result::Ok(ErrorCode::E_INVALID_SPACEVIDLEN),
                "E_INDEX_NOT_FOUND" => ::std::result::Result::Ok(ErrorCode::E_INDEX_NOT_FOUND),
                "E_INVALID_FILTER" => ::std::result::Result::Ok(ErrorCode::E_INVALID_FILTER),
                "E_INVALID_UPDATER" => ::std::result::Result::Ok(ErrorCode::E_INVALID_UPDATER),
                "E_INVALID_STORE" => ::std::result::Result::Ok(ErrorCode::E_INVALID_STORE),
                "E_INVALID_PEER" => ::std::result::Result::Ok(ErrorCode::E_INVALID_PEER),
                "E_RETRY_EXHAUSTED" => ::std::result::Result::Ok(ErrorCode::E_RETRY_EXHAUSTED),
                "E_TRANSFER_LEADER_FAILED" => ::std::result::Result::Ok(ErrorCode::E_TRANSFER_LEADER_FAILED),
                "E_INVALID_STAT_TYPE" => ::std::result::Result::Ok(ErrorCode::E_INVALID_STAT_TYPE),
                "E_INVALID_VID" => ::std::result::Result::Ok(ErrorCode::E_INVALID_VID),
                "E_LOAD_META_FAILED" => ::std::result::Result::Ok(ErrorCode::E_LOAD_META_FAILED),
                "E_FAILED_TO_CHECKPOINT" => ::std::result::Result::Ok(ErrorCode::E_FAILED_TO_CHECKPOINT),
                "E_CHECKPOINT_BLOCKED" => ::std::result::Result::Ok(ErrorCode::E_CHECKPOINT_BLOCKED),
                "E_PARTIAL_RESULT" => ::std::result::Result::Ok(ErrorCode::E_PARTIAL_RESULT),
                "E_FILTER_OUT" => ::std::result::Result::Ok(ErrorCode::E_FILTER_OUT),
                "E_INVALID_DATA" => ::std::result::Result::Ok(ErrorCode::E_INVALID_DATA),
                "E_INVALID_TASK_PARA" => ::std::result::Result::Ok(ErrorCode::E_INVALID_TASK_PARA),
                "E_USER_CANCEL" => ::std::result::Result::Ok(ErrorCode::E_USER_CANCEL),
                "E_UNKNOWN" => ::std::result::Result::Ok(ErrorCode::E_UNKNOWN),
                _ => ::anyhow::bail!("Unable to parse {} as ErrorCode", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ErrorCode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ErrorCode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ErrorCode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct StatType(pub ::std::primitive::i32);

    impl StatType {
        pub const SUM: Self = StatType(1i32);
        pub const COUNT: Self = StatType(2i32);
        pub const AVG: Self = StatType(3i32);
        pub const MAX: Self = StatType(4i32);
        pub const MIN: Self = StatType(5i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "SUM",
                "COUNT",
                "AVG",
                "MAX",
                "MIN",
            ]
        }
    }

    impl ::std::default::Default for StatType {
        fn default() -> Self {
            StatType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a StatType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a StatType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<StatType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: StatType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for StatType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for StatType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                StatType::SUM => "SUM",
                StatType::COUNT => "COUNT",
                StatType::AVG => "AVG",
                StatType::MAX => "MAX",
                StatType::MIN => "MIN",
                StatType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for StatType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "StatType::{}", self)
        }
    }

    impl ::std::str::FromStr for StatType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "SUM" => ::std::result::Result::Ok(StatType::SUM),
                "COUNT" => ::std::result::Result::Ok(StatType::COUNT),
                "AVG" => ::std::result::Result::Ok(StatType::AVG),
                "MAX" => ::std::result::Result::Ok(StatType::MAX),
                "MIN" => ::std::result::Result::Ok(StatType::MIN),
                _ => ::anyhow::bail!("Unable to parse {} as StatType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for StatType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for StatType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for StatType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(StatType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct OrderDirection(pub ::std::primitive::i32);

    impl OrderDirection {
        pub const ASCENDING: Self = OrderDirection(1i32);
        pub const DESCENDING: Self = OrderDirection(2i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "ASCENDING",
                "DESCENDING",
            ]
        }
    }

    impl ::std::default::Default for OrderDirection {
        fn default() -> Self {
            OrderDirection(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a OrderDirection> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a OrderDirection) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<OrderDirection> for ::std::primitive::i32 {
        #[inline]
        fn from(x: OrderDirection) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for OrderDirection {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for OrderDirection {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                OrderDirection::ASCENDING => "ASCENDING",
                OrderDirection::DESCENDING => "DESCENDING",
                OrderDirection(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for OrderDirection {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "OrderDirection::{}", self)
        }
    }

    impl ::std::str::FromStr for OrderDirection {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "ASCENDING" => ::std::result::Result::Ok(OrderDirection::ASCENDING),
                "DESCENDING" => ::std::result::Result::Ok(OrderDirection::DESCENDING),
                _ => ::anyhow::bail!("Unable to parse {} as OrderDirection", string),
            }
        }
    }

    impl ::fbthrift::GetTType for OrderDirection {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for OrderDirection
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for OrderDirection
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(OrderDirection::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EdgeDirection(pub ::std::primitive::i32);

    impl EdgeDirection {
        pub const BOTH: Self = EdgeDirection(1i32);
        pub const IN_EDGE: Self = EdgeDirection(2i32);
        pub const OUT_EDGE: Self = EdgeDirection(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "BOTH",
                "IN_EDGE",
                "OUT_EDGE",
            ]
        }
    }

    impl ::std::default::Default for EdgeDirection {
        fn default() -> Self {
            EdgeDirection(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EdgeDirection> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EdgeDirection) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EdgeDirection> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EdgeDirection) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EdgeDirection {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EdgeDirection {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                EdgeDirection::BOTH => "BOTH",
                EdgeDirection::IN_EDGE => "IN_EDGE",
                EdgeDirection::OUT_EDGE => "OUT_EDGE",
                EdgeDirection(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for EdgeDirection {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EdgeDirection::{}", self)
        }
    }

    impl ::std::str::FromStr for EdgeDirection {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "BOTH" => ::std::result::Result::Ok(EdgeDirection::BOTH),
                "IN_EDGE" => ::std::result::Result::Ok(EdgeDirection::IN_EDGE),
                "OUT_EDGE" => ::std::result::Result::Ok(EdgeDirection::OUT_EDGE),
                _ => ::anyhow::bail!("Unable to parse {} as EdgeDirection", string),
            }
        }
    }

    impl ::fbthrift::GetTType for EdgeDirection {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EdgeDirection
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EdgeDirection
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EdgeDirection::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ScanType(pub ::std::primitive::i32);

    impl ScanType {
        pub const PREFIX: Self = ScanType(1i32);
        pub const RANGE: Self = ScanType(2i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "PREFIX",
                "RANGE",
            ]
        }
    }

    impl ::std::default::Default for ScanType {
        fn default() -> Self {
            ScanType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ScanType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ScanType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ScanType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ScanType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ScanType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ScanType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ScanType::PREFIX => "PREFIX",
                ScanType::RANGE => "RANGE",
                ScanType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ScanType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ScanType::{}", self)
        }
    }

    impl ::std::str::FromStr for ScanType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "PREFIX" => ::std::result::Result::Ok(ScanType::PREFIX),
                "RANGE" => ::std::result::Result::Ok(ScanType::RANGE),
                _ => ::anyhow::bail!("Unable to parse {} as ScanType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ScanType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ScanType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ScanType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ScanType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EngineSignType(pub ::std::primitive::i32);

    impl EngineSignType {
        pub const BLOCK_ON: Self = EngineSignType(1i32);
        pub const BLOCK_OFF: Self = EngineSignType(2i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "BLOCK_ON",
                "BLOCK_OFF",
            ]
        }
    }

    impl ::std::default::Default for EngineSignType {
        fn default() -> Self {
            EngineSignType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EngineSignType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EngineSignType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EngineSignType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EngineSignType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EngineSignType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EngineSignType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                EngineSignType::BLOCK_ON => "BLOCK_ON",
                EngineSignType::BLOCK_OFF => "BLOCK_OFF",
                EngineSignType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for EngineSignType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EngineSignType::{}", self)
        }
    }

    impl ::std::str::FromStr for EngineSignType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "BLOCK_ON" => ::std::result::Result::Ok(EngineSignType::BLOCK_ON),
                "BLOCK_OFF" => ::std::result::Result::Ok(EngineSignType::BLOCK_OFF),
                _ => ::anyhow::bail!("Unable to parse {} as EngineSignType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for EngineSignType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EngineSignType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EngineSignType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EngineSignType::from(p.read_i32()?))
        }
    }

    impl ::std::default::Default for self::PartitionResult {
        fn default() -> Self {
            Self {
                code: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                leader: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::PartitionResult {}
    unsafe impl ::std::marker::Sync for self::PartitionResult {}

    impl ::fbthrift::GetTType for self::PartitionResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PartitionResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PartitionResult");
            p.write_field_begin("code", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.code, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.leader {
                p.write_field_begin("leader", ::fbthrift::TType::Struct, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PartitionResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_code = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_leader = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_code = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                code: field_code.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                leader: field_leader,
            })
        }
    }


    impl ::std::default::Default for self::ResponseCommon {
        fn default() -> Self {
            Self {
                failed_parts: ::std::default::Default::default(),
                latency_in_us: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ResponseCommon {}
    unsafe impl ::std::marker::Sync for self::ResponseCommon {}

    impl ::fbthrift::GetTType for self::ResponseCommon {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ResponseCommon
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ResponseCommon");
            p.write_field_begin("failed_parts", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.failed_parts, p);
            p.write_field_end();
            p.write_field_begin("latency_in_us", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.latency_in_us, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ResponseCommon
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_failed_parts = ::std::option::Option::None;
            let mut field_latency_in_us = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_failed_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_latency_in_us = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                failed_parts: field_failed_parts.unwrap_or_default(),
                latency_in_us: field_latency_in_us.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::StatProp {
        fn default() -> Self {
            Self {
                alias: ::std::default::Default::default(),
                prop: ::std::default::Default::default(),
                stat: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::StatProp {}
    unsafe impl ::std::marker::Sync for self::StatProp {}

    impl ::fbthrift::GetTType for self::StatProp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::StatProp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("StatProp");
            p.write_field_begin("alias", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.alias, p);
            p.write_field_end();
            p.write_field_begin("prop", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.prop, p);
            p.write_field_end();
            p.write_field_begin("stat", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.stat, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::StatProp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_alias = ::std::option::Option::None;
            let mut field_prop = ::std::option::Option::None;
            let mut field_stat = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_alias = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_stat = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                alias: field_alias.unwrap_or_default(),
                prop: field_prop.unwrap_or_default(),
                stat: field_stat.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Expr {
        fn default() -> Self {
            Self {
                alias: ::std::default::Default::default(),
                expr: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Expr {}
    unsafe impl ::std::marker::Sync for self::Expr {}

    impl ::fbthrift::GetTType for self::Expr {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Expr
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Expr");
            p.write_field_begin("alias", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.alias, p);
            p.write_field_end();
            p.write_field_begin("expr", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.expr, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Expr
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_alias = ::std::option::Option::None;
            let mut field_expr = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_alias = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_expr = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                alias: field_alias.unwrap_or_default(),
                expr: field_expr.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgeProp {
        fn default() -> Self {
            Self {
                type_: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgeProp {}
    unsafe impl ::std::marker::Sync for self::EdgeProp {}

    impl ::fbthrift::GetTType for self::EdgeProp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgeProp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgeProp");
            p.write_field_begin("type", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgeProp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_type = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                type_: field_type.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::VertexProp {
        fn default() -> Self {
            Self {
                tag: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::VertexProp {}
    unsafe impl ::std::marker::Sync for self::VertexProp {}

    impl ::fbthrift::GetTType for self::VertexProp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::VertexProp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("VertexProp");
            p.write_field_begin("tag", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.tag, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::VertexProp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_tag = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_tag = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag: field_tag.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::OrderBy {
        fn default() -> Self {
            Self {
                prop: ::std::default::Default::default(),
                direction: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::OrderBy {}
    unsafe impl ::std::marker::Sync for self::OrderBy {}

    impl ::fbthrift::GetTType for self::OrderBy {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::OrderBy
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("OrderBy");
            p.write_field_begin("prop", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.prop, p);
            p.write_field_end();
            p.write_field_begin("direction", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.direction, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::OrderBy
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_prop = ::std::option::Option::None;
            let mut field_direction = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_prop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_direction = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                prop: field_prop.unwrap_or_default(),
                direction: field_direction.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TraverseSpec {
        fn default() -> Self {
            Self {
                edge_types: ::std::default::Default::default(),
                edge_direction: crate::types::EdgeDirection::BOTH,
                dedup: false,
                stat_props: ::std::option::Option::None,
                vertex_props: ::std::option::Option::None,
                edge_props: ::std::option::Option::None,
                expressions: ::std::option::Option::None,
                order_by: ::std::option::Option::None,
                random: ::std::option::Option::None,
                limit: ::std::option::Option::None,
                filter: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TraverseSpec {}
    unsafe impl ::std::marker::Sync for self::TraverseSpec {}

    impl ::fbthrift::GetTType for self::TraverseSpec {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TraverseSpec
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TraverseSpec");
            p.write_field_begin("edge_types", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.edge_types, p);
            p.write_field_end();
            p.write_field_begin("edge_direction", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.edge_direction, p);
            p.write_field_end();
            p.write_field_begin("dedup", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.dedup, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.stat_props {
                p.write_field_begin("stat_props", ::fbthrift::TType::List, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.vertex_props {
                p.write_field_begin("vertex_props", ::fbthrift::TType::List, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.edge_props {
                p.write_field_begin("edge_props", ::fbthrift::TType::List, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.expressions {
                p.write_field_begin("expressions", ::fbthrift::TType::List, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.order_by {
                p.write_field_begin("order_by", ::fbthrift::TType::List, 8);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.random {
                p.write_field_begin("random", ::fbthrift::TType::Bool, 9);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.limit {
                p.write_field_begin("limit", ::fbthrift::TType::I64, 10);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.filter {
                p.write_field_begin("filter", ::fbthrift::TType::String, 11);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TraverseSpec
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_edge_types = ::std::option::Option::None;
            let mut field_edge_direction = ::std::option::Option::None;
            let mut field_dedup = ::std::option::Option::None;
            let mut field_stat_props = ::std::option::Option::None;
            let mut field_vertex_props = ::std::option::Option::None;
            let mut field_edge_props = ::std::option::Option::None;
            let mut field_expressions = ::std::option::Option::None;
            let mut field_order_by = ::std::option::Option::None;
            let mut field_random = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_edge_types = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_edge_direction = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_dedup = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_stat_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_vertex_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_edge_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 7) => field_expressions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 8) => field_order_by = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 9) => field_random = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 10) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 11) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                edge_types: field_edge_types.unwrap_or_default(),
                edge_direction: field_edge_direction.unwrap_or_else(|| crate::types::EdgeDirection::BOTH),
                dedup: field_dedup.unwrap_or_else(|| false),
                stat_props: field_stat_props,
                vertex_props: field_vertex_props,
                edge_props: field_edge_props,
                expressions: field_expressions,
                order_by: field_order_by,
                random: field_random,
                limit: field_limit,
                filter: field_filter,
            })
        }
    }


    impl ::std::default::Default for self::GetNeighborsRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                column_names: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                traverse_spec: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetNeighborsRequest {}
    unsafe impl ::std::marker::Sync for self::GetNeighborsRequest {}

    impl ::fbthrift::GetTType for self::GetNeighborsRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetNeighborsRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetNeighborsRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("column_names", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.column_names, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("traverse_spec", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.traverse_spec, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetNeighborsRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_column_names = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_traverse_spec = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_traverse_spec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                column_names: field_column_names.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                traverse_spec: field_traverse_spec.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetNeighborsResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                vertices: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetNeighborsResponse {}
    unsafe impl ::std::marker::Sync for self::GetNeighborsResponse {}

    impl ::fbthrift::GetTType for self::GetNeighborsResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetNeighborsResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetNeighborsResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.vertices {
                p.write_field_begin("vertices", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetNeighborsResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_vertices = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_vertices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                vertices: field_vertices,
            })
        }
    }


    impl ::std::default::Default for self::ExecResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ExecResponse {}
    unsafe impl ::std::marker::Sync for self::ExecResponse {}

    impl ::fbthrift::GetTType for self::ExecResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ExecResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ExecResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ExecResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetPropRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                column_names: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                vertex_props: ::std::option::Option::None,
                edge_props: ::std::option::Option::None,
                expressions: ::std::option::Option::None,
                dedup: false,
                order_by: ::std::option::Option::None,
                limit: ::std::option::Option::None,
                filter: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetPropRequest {}
    unsafe impl ::std::marker::Sync for self::GetPropRequest {}

    impl ::fbthrift::GetTType for self::GetPropRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetPropRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetPropRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("column_names", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.column_names, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.vertex_props {
                p.write_field_begin("vertex_props", ::fbthrift::TType::List, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.edge_props {
                p.write_field_begin("edge_props", ::fbthrift::TType::List, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.expressions {
                p.write_field_begin("expressions", ::fbthrift::TType::List, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("dedup", ::fbthrift::TType::Bool, 7);
            ::fbthrift::Serialize::write(&self.dedup, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.order_by {
                p.write_field_begin("order_by", ::fbthrift::TType::List, 8);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.limit {
                p.write_field_begin("limit", ::fbthrift::TType::I64, 9);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.filter {
                p.write_field_begin("filter", ::fbthrift::TType::String, 10);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetPropRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_column_names = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_vertex_props = ::std::option::Option::None;
            let mut field_edge_props = ::std::option::Option::None;
            let mut field_expressions = ::std::option::Option::None;
            let mut field_dedup = ::std::option::Option::None;
            let mut field_order_by = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_column_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_vertex_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_edge_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_expressions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 7) => field_dedup = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 8) => field_order_by = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 9) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 10) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                column_names: field_column_names.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                vertex_props: field_vertex_props,
                edge_props: field_edge_props,
                expressions: field_expressions,
                dedup: field_dedup.unwrap_or_else(|| false),
                order_by: field_order_by,
                limit: field_limit,
                filter: field_filter,
            })
        }
    }


    impl ::std::default::Default for self::GetPropResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                props: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetPropResponse {}
    unsafe impl ::std::marker::Sync for self::GetPropResponse {}

    impl ::fbthrift::GetTType for self::GetPropResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetPropResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetPropResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.props {
                p.write_field_begin("props", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetPropResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                props: field_props,
            })
        }
    }


    impl ::std::default::Default for self::NewTag {
        fn default() -> Self {
            Self {
                tag_id: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NewTag {}
    unsafe impl ::std::marker::Sync for self::NewTag {}

    impl ::fbthrift::GetTType for self::NewTag {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NewTag
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NewTag");
            p.write_field_begin("tag_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.tag_id, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NewTag
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_tag_id = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                tag_id: field_tag_id.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NewVertex {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                tags: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NewVertex {}
    unsafe impl ::std::marker::Sync for self::NewVertex {}

    impl ::fbthrift::GetTType for self::NewVertex {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NewVertex
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NewVertex");
            p.write_field_begin("id", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("tags", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.tags, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NewVertex
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_id = ::std::option::Option::None;
            let mut field_tags = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_tags = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                tags: field_tags.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdgeKey {
        fn default() -> Self {
            Self {
                src: ::std::default::Default::default(),
                edge_type: ::std::default::Default::default(),
                ranking: ::std::default::Default::default(),
                dst: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdgeKey {}
    unsafe impl ::std::marker::Sync for self::EdgeKey {}

    impl ::fbthrift::GetTType for self::EdgeKey {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdgeKey
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdgeKey");
            p.write_field_begin("src", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.src, p);
            p.write_field_end();
            p.write_field_begin("edge_type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.edge_type, p);
            p.write_field_end();
            p.write_field_begin("ranking", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.ranking, p);
            p.write_field_end();
            p.write_field_begin("dst", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.dst, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdgeKey
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_src = ::std::option::Option::None;
            let mut field_edge_type = ::std::option::Option::None;
            let mut field_ranking = ::std::option::Option::None;
            let mut field_dst = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_src = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_edge_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_ranking = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_dst = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                src: field_src.unwrap_or_default(),
                edge_type: field_edge_type.unwrap_or_default(),
                ranking: field_ranking.unwrap_or_default(),
                dst: field_dst.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NewEdge {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
                props: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NewEdge {}
    unsafe impl ::std::marker::Sync for self::NewEdge {}

    impl ::fbthrift::GetTType for self::NewEdge {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NewEdge
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NewEdge");
            p.write_field_begin("key", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_begin("props", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.props, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NewEdge
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_key = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
                props: field_props.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddVerticesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                prop_names: ::std::default::Default::default(),
                overwritable: true,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddVerticesRequest {}
    unsafe impl ::std::marker::Sync for self::AddVerticesRequest {}

    impl ::fbthrift::GetTType for self::AddVerticesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddVerticesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddVerticesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("prop_names", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.prop_names, p);
            p.write_field_end();
            p.write_field_begin("overwritable", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.overwritable, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddVerticesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_prop_names = ::std::option::Option::None;
            let mut field_overwritable = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_prop_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_overwritable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                prop_names: field_prop_names.unwrap_or_default(),
                overwritable: field_overwritable.unwrap_or_else(|| true),
            })
        }
    }


    impl ::std::default::Default for self::AddEdgesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                prop_names: ::std::default::Default::default(),
                overwritable: true,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddEdgesRequest {}
    unsafe impl ::std::marker::Sync for self::AddEdgesRequest {}

    impl ::fbthrift::GetTType for self::AddEdgesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddEdgesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddEdgesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("prop_names", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.prop_names, p);
            p.write_field_end();
            p.write_field_begin("overwritable", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.overwritable, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddEdgesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_prop_names = ::std::option::Option::None;
            let mut field_overwritable = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_prop_names = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_overwritable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                prop_names: field_prop_names.unwrap_or_default(),
                overwritable: field_overwritable.unwrap_or_else(|| true),
            })
        }
    }


    impl ::std::default::Default for self::DeleteVerticesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DeleteVerticesRequest {}
    unsafe impl ::std::marker::Sync for self::DeleteVerticesRequest {}

    impl ::fbthrift::GetTType for self::DeleteVerticesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DeleteVerticesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DeleteVerticesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DeleteVerticesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DeleteEdgesRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DeleteEdgesRequest {}
    unsafe impl ::std::marker::Sync for self::DeleteEdgesRequest {}

    impl ::fbthrift::GetTType for self::DeleteEdgesRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DeleteEdgesRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DeleteEdgesRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DeleteEdgesRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UpdateResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                props: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateResponse {}
    unsafe impl ::std::marker::Sync for self::UpdateResponse {}

    impl ::fbthrift::GetTType for self::UpdateResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.props {
                p.write_field_begin("props", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_props = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                props: field_props,
            })
        }
    }


    impl ::std::default::Default for self::UpdatedProp {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdatedProp {}
    unsafe impl ::std::marker::Sync for self::UpdatedProp {}

    impl ::fbthrift::GetTType for self::UpdatedProp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdatedProp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdatedProp");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdatedProp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_name = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                value: field_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UpdateVertexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                vertex_id: ::std::default::Default::default(),
                tag_id: ::std::default::Default::default(),
                updated_props: ::std::default::Default::default(),
                insertable: ::std::option::Option::Some(false),
                return_props: ::std::option::Option::None,
                condition: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateVertexRequest {}
    unsafe impl ::std::marker::Sync for self::UpdateVertexRequest {}

    impl ::fbthrift::GetTType for self::UpdateVertexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateVertexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateVertexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("vertex_id", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.vertex_id, p);
            p.write_field_end();
            p.write_field_begin("tag_id", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.tag_id, p);
            p.write_field_end();
            p.write_field_begin("updated_props", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.updated_props, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.insertable {
                p.write_field_begin("insertable", ::fbthrift::TType::Bool, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.return_props {
                p.write_field_begin("return_props", ::fbthrift::TType::List, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.condition {
                p.write_field_begin("condition", ::fbthrift::TType::String, 8);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateVertexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_vertex_id = ::std::option::Option::None;
            let mut field_tag_id = ::std::option::Option::None;
            let mut field_updated_props = ::std::option::Option::None;
            let mut field_insertable = ::std::option::Option::None;
            let mut field_return_props = ::std::option::Option::None;
            let mut field_condition = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_vertex_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_tag_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_updated_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 6) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 7) => field_return_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 8) => field_condition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                vertex_id: field_vertex_id.unwrap_or_default(),
                tag_id: field_tag_id.unwrap_or_default(),
                updated_props: field_updated_props.unwrap_or_default(),
                insertable: field_insertable,
                return_props: field_return_props,
                condition: field_condition,
            })
        }
    }


    impl ::std::default::Default for self::UpdateEdgeRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                edge_key: ::std::default::Default::default(),
                updated_props: ::std::default::Default::default(),
                insertable: ::std::option::Option::Some(false),
                return_props: ::std::option::Option::None,
                condition: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UpdateEdgeRequest {}
    unsafe impl ::std::marker::Sync for self::UpdateEdgeRequest {}

    impl ::fbthrift::GetTType for self::UpdateEdgeRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UpdateEdgeRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UpdateEdgeRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("edge_key", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.edge_key, p);
            p.write_field_end();
            p.write_field_begin("updated_props", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.updated_props, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.insertable {
                p.write_field_begin("insertable", ::fbthrift::TType::Bool, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.return_props {
                p.write_field_begin("return_props", ::fbthrift::TType::List, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.condition {
                p.write_field_begin("condition", ::fbthrift::TType::String, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UpdateEdgeRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_edge_key = ::std::option::Option::None;
            let mut field_updated_props = ::std::option::Option::None;
            let mut field_insertable = ::std::option::Option::None;
            let mut field_return_props = ::std::option::Option::None;
            let mut field_condition = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_edge_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_updated_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_insertable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_return_props = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 7) => field_condition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                edge_key: field_edge_key.unwrap_or_default(),
                updated_props: field_updated_props.unwrap_or_default(),
                insertable: field_insertable,
                return_props: field_return_props,
                condition: field_condition,
            })
        }
    }


    impl ::std::default::Default for self::GetUUIDReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetUUIDReq {}
    unsafe impl ::std::marker::Sync for self::GetUUIDReq {}

    impl ::fbthrift::GetTType for self::GetUUIDReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetUUIDReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetUUIDReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetUUIDResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetUUIDResp {}
    unsafe impl ::std::marker::Sync for self::GetUUIDResp {}

    impl ::fbthrift::GetTType for self::GetUUIDResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetUUIDResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetUUIDResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetUUIDResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LookupIndexResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                data: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LookupIndexResp {}
    unsafe impl ::std::marker::Sync for self::LookupIndexResp {}

    impl ::fbthrift::GetTType for self::LookupIndexResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LookupIndexResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LookupIndexResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.data {
                p.write_field_begin("data", ::fbthrift::TType::Struct, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LookupIndexResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_data = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                data: field_data,
            })
        }
    }


    impl ::std::default::Default for self::IndexColumnHint {
        fn default() -> Self {
            Self {
                column_name: ::std::default::Default::default(),
                scan_type: ::std::default::Default::default(),
                begin_value: ::std::default::Default::default(),
                end_value: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexColumnHint {}
    unsafe impl ::std::marker::Sync for self::IndexColumnHint {}

    impl ::fbthrift::GetTType for self::IndexColumnHint {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexColumnHint
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexColumnHint");
            p.write_field_begin("column_name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.column_name, p);
            p.write_field_end();
            p.write_field_begin("scan_type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.scan_type, p);
            p.write_field_end();
            p.write_field_begin("begin_value", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.begin_value, p);
            p.write_field_end();
            p.write_field_begin("end_value", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.end_value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexColumnHint
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_column_name = ::std::option::Option::None;
            let mut field_scan_type = ::std::option::Option::None;
            let mut field_begin_value = ::std::option::Option::None;
            let mut field_end_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_column_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_scan_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_begin_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_end_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                column_name: field_column_name.unwrap_or_default(),
                scan_type: field_scan_type.unwrap_or_default(),
                begin_value: field_begin_value.unwrap_or_default(),
                end_value: field_end_value.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IndexQueryContext {
        fn default() -> Self {
            Self {
                index_id: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                column_hints: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexQueryContext {}
    unsafe impl ::std::marker::Sync for self::IndexQueryContext {}

    impl ::fbthrift::GetTType for self::IndexQueryContext {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexQueryContext
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexQueryContext");
            p.write_field_begin("index_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.index_id, p);
            p.write_field_end();
            p.write_field_begin("filter", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.filter, p);
            p.write_field_end();
            p.write_field_begin("column_hints", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.column_hints, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexQueryContext
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_index_id = ::std::option::Option::None;
            let mut field_filter = ::std::option::Option::None;
            let mut field_column_hints = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_filter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_column_hints = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                index_id: field_index_id.unwrap_or_default(),
                filter: field_filter.unwrap_or_default(),
                column_hints: field_column_hints.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::IndexSpec {
        fn default() -> Self {
            Self {
                contexts: ::std::default::Default::default(),
                is_edge: ::std::default::Default::default(),
                tag_or_edge_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::IndexSpec {}
    unsafe impl ::std::marker::Sync for self::IndexSpec {}

    impl ::fbthrift::GetTType for self::IndexSpec {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IndexSpec
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IndexSpec");
            p.write_field_begin("contexts", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.contexts, p);
            p.write_field_end();
            p.write_field_begin("is_edge", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.is_edge, p);
            p.write_field_end();
            p.write_field_begin("tag_or_edge_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.tag_or_edge_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IndexSpec
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_contexts = ::std::option::Option::None;
            let mut field_is_edge = ::std::option::Option::None;
            let mut field_tag_or_edge_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_contexts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_is_edge = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_tag_or_edge_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                contexts: field_contexts.unwrap_or_default(),
                is_edge: field_is_edge.unwrap_or_default(),
                tag_or_edge_id: field_tag_or_edge_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::LookupIndexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                indices: ::std::default::Default::default(),
                return_columns: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LookupIndexRequest {}
    unsafe impl ::std::marker::Sync for self::LookupIndexRequest {}

    impl ::fbthrift::GetTType for self::LookupIndexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LookupIndexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LookupIndexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("indices", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.indices, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.return_columns {
                p.write_field_begin("return_columns", ::fbthrift::TType::List, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LookupIndexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_indices = ::std::option::Option::None;
            let mut field_return_columns = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_indices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_return_columns = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                indices: field_indices.unwrap_or_default(),
                return_columns: field_return_columns,
            })
        }
    }


    impl ::std::default::Default for self::LookupAndTraverseRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                indices: ::std::default::Default::default(),
                traverse_spec: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::LookupAndTraverseRequest {}
    unsafe impl ::std::marker::Sync for self::LookupAndTraverseRequest {}

    impl ::fbthrift::GetTType for self::LookupAndTraverseRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::LookupAndTraverseRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("LookupAndTraverseRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("indices", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.indices, p);
            p.write_field_end();
            p.write_field_begin("traverse_spec", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.traverse_spec, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::LookupAndTraverseRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_indices = ::std::option::Option::None;
            let mut field_traverse_spec = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_indices = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_traverse_spec = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                indices: field_indices.unwrap_or_default(),
                traverse_spec: field_traverse_spec.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TaskPara {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::option::Option::None,
                task_specfic_paras: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TaskPara {}
    unsafe impl ::std::marker::Sync for self::TaskPara {}

    impl ::fbthrift::GetTType for self::TaskPara {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TaskPara
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TaskPara");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.parts {
                p.write_field_begin("parts", ::fbthrift::TType::List, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.task_specfic_paras {
                p.write_field_begin("task_specfic_paras", ::fbthrift::TType::List, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TaskPara
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_task_specfic_paras = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_task_specfic_paras = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts,
                task_specfic_paras: field_task_specfic_paras,
            })
        }
    }


    impl ::std::default::Default for self::AddAdminTaskRequest {
        fn default() -> Self {
            Self {
                cmd: ::std::default::Default::default(),
                job_id: ::std::default::Default::default(),
                task_id: ::std::default::Default::default(),
                para: ::std::default::Default::default(),
                concurrency: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddAdminTaskRequest {}
    unsafe impl ::std::marker::Sync for self::AddAdminTaskRequest {}

    impl ::fbthrift::GetTType for self::AddAdminTaskRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddAdminTaskRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddAdminTaskRequest");
            p.write_field_begin("cmd", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.cmd, p);
            p.write_field_end();
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.job_id, p);
            p.write_field_end();
            p.write_field_begin("task_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.task_id, p);
            p.write_field_end();
            p.write_field_begin("para", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.para, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.concurrency {
                p.write_field_begin("concurrency", ::fbthrift::TType::I32, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddAdminTaskRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_cmd = ::std::option::Option::None;
            let mut field_job_id = ::std::option::Option::None;
            let mut field_task_id = ::std::option::Option::None;
            let mut field_para = ::std::option::Option::None;
            let mut field_concurrency = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_cmd = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_para = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_concurrency = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                cmd: field_cmd.unwrap_or_default(),
                job_id: field_job_id.unwrap_or_default(),
                task_id: field_task_id.unwrap_or_default(),
                para: field_para.unwrap_or_default(),
                concurrency: field_concurrency,
            })
        }
    }


    impl ::std::default::Default for self::StopAdminTaskRequest {
        fn default() -> Self {
            Self {
                job_id: ::std::default::Default::default(),
                task_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::StopAdminTaskRequest {}
    unsafe impl ::std::marker::Sync for self::StopAdminTaskRequest {}

    impl ::fbthrift::GetTType for self::StopAdminTaskRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::StopAdminTaskRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("StopAdminTaskRequest");
            p.write_field_begin("job_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.job_id, p);
            p.write_field_end();
            p.write_field_begin("task_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.task_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::StopAdminTaskRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_job_id = ::std::option::Option::None;
            let mut field_task_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_job_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_task_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                job_id: field_job_id.unwrap_or_default(),
                task_id: field_task_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AdminExecResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AdminExecResp {}
    unsafe impl ::std::marker::Sync for self::AdminExecResp {}

    impl ::fbthrift::GetTType for self::AdminExecResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AdminExecResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AdminExecResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AdminExecResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TransLeaderReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                new_leader: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TransLeaderReq {}
    unsafe impl ::std::marker::Sync for self::TransLeaderReq {}

    impl ::fbthrift::GetTType for self::TransLeaderReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TransLeaderReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TransLeaderReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("new_leader", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.new_leader, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TransLeaderReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_new_leader = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_new_leader = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                new_leader: field_new_leader.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddPartReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                as_learner: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddPartReq {}
    unsafe impl ::std::marker::Sync for self::AddPartReq {}

    impl ::fbthrift::GetTType for self::AddPartReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddPartReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddPartReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("as_learner", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.as_learner, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddPartReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_as_learner = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_as_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                as_learner: field_as_learner.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AddLearnerReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                learner: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AddLearnerReq {}
    unsafe impl ::std::marker::Sync for self::AddLearnerReq {}

    impl ::fbthrift::GetTType for self::AddLearnerReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AddLearnerReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AddLearnerReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("learner", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.learner, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AddLearnerReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_learner = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_learner = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                learner: field_learner.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RemovePartReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemovePartReq {}
    unsafe impl ::std::marker::Sync for self::RemovePartReq {}

    impl ::fbthrift::GetTType for self::RemovePartReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemovePartReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemovePartReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemovePartReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MemberChangeReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                peer: ::std::default::Default::default(),
                add: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MemberChangeReq {}
    unsafe impl ::std::marker::Sync for self::MemberChangeReq {}

    impl ::fbthrift::GetTType for self::MemberChangeReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MemberChangeReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MemberChangeReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("peer", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.peer, p);
            p.write_field_end();
            p.write_field_begin("add", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.add, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MemberChangeReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_peer = ::std::option::Option::None;
            let mut field_add = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_peer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                peer: field_peer.unwrap_or_default(),
                add: field_add.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CatchUpDataReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                target: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CatchUpDataReq {}
    unsafe impl ::std::marker::Sync for self::CatchUpDataReq {}

    impl ::fbthrift::GetTType for self::CatchUpDataReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CatchUpDataReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CatchUpDataReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("target", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.target, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CatchUpDataReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_target = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_target = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                target: field_target.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetLeaderReq {
        fn default() -> Self {
            Self {
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetLeaderReq {}
    unsafe impl ::std::marker::Sync for self::GetLeaderReq {}

    impl ::fbthrift::GetTType for self::GetLeaderReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetLeaderReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetLeaderReq");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
            })
        }
    }


    impl ::std::default::Default for self::CreateCPRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CreateCPRequest {}
    unsafe impl ::std::marker::Sync for self::CreateCPRequest {}

    impl ::fbthrift::GetTType for self::CreateCPRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CreateCPRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CreateCPRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CreateCPRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DropCPRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DropCPRequest {}
    unsafe impl ::std::marker::Sync for self::DropCPRequest {}

    impl ::fbthrift::GetTType for self::DropCPRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DropCPRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DropCPRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DropCPRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::BlockingSignRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                sign: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::BlockingSignRequest {}
    unsafe impl ::std::marker::Sync for self::BlockingSignRequest {}

    impl ::fbthrift::GetTType for self::BlockingSignRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::BlockingSignRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("BlockingSignRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("sign", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.sign, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::BlockingSignRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_sign = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_sign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                sign: field_sign.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetLeaderPartsResp {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                leader_parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetLeaderPartsResp {}
    unsafe impl ::std::marker::Sync for self::GetLeaderPartsResp {}

    impl ::fbthrift::GetTType for self::GetLeaderPartsResp {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetLeaderPartsResp
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetLeaderPartsResp");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("leader_parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.leader_parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetLeaderPartsResp
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_leader_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_leader_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                leader_parts: field_leader_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CheckPeersReq {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                part_id: ::std::default::Default::default(),
                peers: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CheckPeersReq {}
    unsafe impl ::std::marker::Sync for self::CheckPeersReq {}

    impl ::fbthrift::GetTType for self::CheckPeersReq {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckPeersReq
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckPeersReq");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("part_id", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.part_id, p);
            p.write_field_end();
            p.write_field_begin("peers", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.peers, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckPeersReq
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_part_id = ::std::option::Option::None;
            let mut field_peers = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_part_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_peers = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                part_id: field_part_id.unwrap_or_default(),
                peers: field_peers.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::RebuildIndexRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                index_id: ::std::default::Default::default(),
                is_offline: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RebuildIndexRequest {}
    unsafe impl ::std::marker::Sync for self::RebuildIndexRequest {}

    impl ::fbthrift::GetTType for self::RebuildIndexRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RebuildIndexRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RebuildIndexRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("index_id", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.index_id, p);
            p.write_field_end();
            p.write_field_begin("is_offline", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.is_offline, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RebuildIndexRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_index_id = ::std::option::Option::None;
            let mut field_is_offline = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_index_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_is_offline = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                index_id: field_index_id.unwrap_or_default(),
                is_offline: field_is_offline.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KVGetRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
                return_partly: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KVGetRequest {}
    unsafe impl ::std::marker::Sync for self::KVGetRequest {}

    impl ::fbthrift::GetTType for self::KVGetRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KVGetRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KVGetRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_begin("return_partly", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.return_partly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KVGetRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let mut field_return_partly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_return_partly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
                return_partly: field_return_partly.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KVGetResponse {
        fn default() -> Self {
            Self {
                result: ::std::default::Default::default(),
                key_values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KVGetResponse {}
    unsafe impl ::std::marker::Sync for self::KVGetResponse {}

    impl ::fbthrift::GetTType for self::KVGetResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KVGetResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KVGetResponse");
            p.write_field_begin("result", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.result, p);
            p.write_field_end();
            p.write_field_begin("key_values", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.key_values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KVGetResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_result = ::std::option::Option::None;
            let mut field_key_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_result = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_key_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                result: field_result.unwrap_or_default(),
                key_values: field_key_values.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KVPutRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KVPutRequest {}
    unsafe impl ::std::marker::Sync for self::KVPutRequest {}

    impl ::fbthrift::GetTType for self::KVPutRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KVPutRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KVPutRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KVPutRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::KVRemoveRequest {
        fn default() -> Self {
            Self {
                space_id: ::std::default::Default::default(),
                parts: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::KVRemoveRequest {}
    unsafe impl ::std::marker::Sync for self::KVRemoveRequest {}

    impl ::fbthrift::GetTType for self::KVRemoveRequest {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::KVRemoveRequest
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("KVRemoveRequest");
            p.write_field_begin("space_id", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.space_id, p);
            p.write_field_end();
            p.write_field_begin("parts", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.parts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::KVRemoveRequest
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_space_id = ::std::option::Option::None;
            let mut field_parts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_space_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_parts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                space_id: field_space_id.unwrap_or_default(),
                parts: field_parts.unwrap_or_default(),
            })
        }
    }

}

pub mod dependencies {
    pub use common as common;
    pub use meta as meta;
}

pub mod services {
    pub mod graph_storage_service {

        #[derive(Clone, Debug)]
        pub enum GetNeighborsExn {
            Success(crate::types::GetNeighborsResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetNeighborsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetNeighborsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetNeighborsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetNeighborsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetNeighbors");
                match self {
                    GetNeighborsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetNeighborsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetNeighborsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetNeighborsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetNeighborsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetNeighborsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPropsExn {
            Success(crate::types::GetPropResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPropsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetPropsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetPropsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetProps");
                match self {
                    GetPropsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPropsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPropsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPropsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPropsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPropsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddVerticesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddVerticesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddVertices");
                match self {
                    AddVerticesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddVerticesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddVerticesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddEdgesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddEdgesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddEdges");
                match self {
                    AddEdgesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddEdgesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddEdgesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteEdgesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteEdgesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DeleteEdgesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DeleteEdgesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DeleteEdges");
                match self {
                    DeleteEdgesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DeleteEdgesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteEdgesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DeleteEdgesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DeleteVerticesExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DeleteVerticesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DeleteVerticesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DeleteVerticesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DeleteVertices");
                match self {
                    DeleteVerticesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DeleteVerticesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DeleteVerticesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DeleteVerticesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DeleteVerticesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DeleteVerticesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateVertexExn {
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateVertexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UpdateVertexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UpdateVertexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UpdateVertex");
                match self {
                    UpdateVertexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UpdateVertexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateVertexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UpdateVertexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateVertexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateVertexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateEdgeExn {
            Success(crate::types::UpdateResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UpdateEdgeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UpdateEdgeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UpdateEdgeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UpdateEdge");
                match self {
                    UpdateEdgeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UpdateEdgeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UpdateEdgeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UpdateEdgeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUUIDExn {
            Success(crate::types::GetUUIDResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetUUIDExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetUUIDExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetUUIDExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetUUID");
                match self {
                    GetUUIDExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetUUIDExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetUUIDExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetUUIDExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUUIDExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUUIDExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LookupIndexExn {
            Success(crate::types::LookupIndexResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LookupIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                LookupIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for LookupIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LookupIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("LookupIndex");
                match self {
                    LookupIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    LookupIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LookupIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(LookupIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LookupIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LookupIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum LookupAndTraverseExn {
            Success(crate::types::GetNeighborsResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for LookupAndTraverseExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                LookupAndTraverseExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for LookupAndTraverseExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for LookupAndTraverseExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("LookupAndTraverse");
                match self {
                    LookupAndTraverseExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    LookupAndTraverseExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for LookupAndTraverseExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(LookupAndTraverseExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "LookupAndTraverseExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "LookupAndTraverseExn"),
                    )
                    .into(),
                )
            }
        }
    }

    pub mod storage_admin_service {

        #[derive(Clone, Debug)]
        pub enum TransLeaderExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for TransLeaderExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                TransLeaderExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for TransLeaderExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("TransLeader");
                match self {
                    TransLeaderExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    TransLeaderExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for TransLeaderExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(TransLeaderExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "TransLeaderExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "TransLeaderExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddPartExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddPartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddPartExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddPartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddPart");
                match self {
                    AddPartExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddPartExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddPartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddPartExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddPartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddPartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddLearnerExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddLearnerExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddLearnerExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddLearnerExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddLearner");
                match self {
                    AddLearnerExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddLearnerExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddLearnerExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddLearnerExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddLearnerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddLearnerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemovePartExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemovePartExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemovePartExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemovePartExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemovePart");
                match self {
                    RemovePartExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemovePartExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemovePartExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemovePartExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemovePartExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemovePartExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MemberChangeExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MemberChangeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MemberChangeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MemberChangeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("MemberChange");
                match self {
                    MemberChangeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MemberChangeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MemberChangeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(MemberChangeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MemberChangeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MemberChangeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum WaitingForCatchUpDataExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for WaitingForCatchUpDataExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                WaitingForCatchUpDataExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for WaitingForCatchUpDataExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("WaitingForCatchUpData");
                match self {
                    WaitingForCatchUpDataExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    WaitingForCatchUpDataExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for WaitingForCatchUpDataExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(WaitingForCatchUpDataExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "WaitingForCatchUpDataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "WaitingForCatchUpDataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateCheckpointExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CreateCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CreateCheckpointExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CreateCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CreateCheckpoint");
                match self {
                    CreateCheckpointExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CreateCheckpointExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CreateCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CreateCheckpointExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropCheckpointExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DropCheckpointExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DropCheckpointExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DropCheckpointExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DropCheckpoint");
                match self {
                    DropCheckpointExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DropCheckpointExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DropCheckpointExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DropCheckpointExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropCheckpointExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropCheckpointExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum BlockingWritesExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for BlockingWritesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                BlockingWritesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for BlockingWritesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("BlockingWrites");
                match self {
                    BlockingWritesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    BlockingWritesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for BlockingWritesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(BlockingWritesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "BlockingWritesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "BlockingWritesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildTagIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    RebuildTagIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildTagIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildTagIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RebuildEdgeIndexExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    RebuildEdgeIndexExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RebuildEdgeIndexExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RebuildEdgeIndexExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetLeaderPartsExn {
            Success(crate::types::GetLeaderPartsResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetLeaderPartsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetLeaderPartsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetLeaderPartsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetLeaderPartsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetLeaderParts");
                match self {
                    GetLeaderPartsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetLeaderPartsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetLeaderPartsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetLeaderPartsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetLeaderPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetLeaderPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckPeersExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckPeersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CheckPeersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CheckPeersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CheckPeers");
                match self {
                    CheckPeersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckPeersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckPeersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckPeersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckPeersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckPeersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddAdminTaskExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddAdminTaskExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddAdminTaskExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddAdminTaskExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddAdminTaskExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddAdminTask");
                match self {
                    AddAdminTaskExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddAdminTaskExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddAdminTaskExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AddAdminTaskExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddAdminTaskExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddAdminTaskExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum StopAdminTaskExn {
            Success(crate::types::AdminExecResp),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for StopAdminTaskExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                StopAdminTaskExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for StopAdminTaskExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for StopAdminTaskExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("StopAdminTask");
                match self {
                    StopAdminTaskExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    StopAdminTaskExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for StopAdminTaskExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(StopAdminTaskExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "StopAdminTaskExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "StopAdminTaskExn"),
                    )
                    .into(),
                )
            }
        }
    }

    pub mod general_storage_service {

        #[derive(Clone, Debug)]
        pub enum GetExn {
            Success(crate::types::KVGetResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Get");
                match self {
                    GetExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum PutExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for PutExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                PutExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for PutExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Put");
                match self {
                    PutExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    PutExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for PutExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(PutExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "PutExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "PutExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveExn {
            Success(crate::types::ExecResponse),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Remove");
                match self {
                    RemoveExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {

    pub struct GraphStorageServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> GraphStorageServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait GraphStorageService: ::std::marker::Send {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> + ::std::marker::Send + 'static>>;
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> + ::std::marker::Send + 'static>>;
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> + ::std::marker::Send + 'static>>;
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> + ::std::marker::Send + 'static>>;
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>>;
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>>;
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>>;
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>>;
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> + ::std::marker::Send + 'static>>;
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> + ::std::marker::Send + 'static>>;
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> GraphStorageService for GraphStorageServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getNeighbors",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::GetNeighborsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::GetNeighborsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::GetNeighborsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::GetNeighborsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::GetNeighborsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::GetNeighborsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getProps",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::GetPropsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::GetPropsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::GetPropsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::GetPropsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::GetPropsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::GetPropsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addVertices",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::AddVerticesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::AddVerticesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::AddVerticesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::AddVerticesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::AddVerticesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::AddVerticesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addEdges",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::AddEdgesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::AddEdgesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::AddEdgesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::AddEdgesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::AddEdgesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::AddEdgesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteEdges",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::DeleteEdgesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::DeleteEdgesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::DeleteEdgesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteEdgesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteEdgesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteEdgesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteVertices",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::DeleteVerticesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::DeleteVerticesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::DeleteVerticesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteVerticesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteVerticesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::DeleteVerticesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateVertex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::UpdateVertexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::UpdateVertexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::UpdateVertexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateVertexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateVertexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateVertexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateEdge",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::UpdateEdgeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::UpdateEdgeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::UpdateEdgeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateEdgeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateEdgeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::UpdateEdgeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUUID",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::GetUUIDExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::GetUUIDExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::GetUUIDExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::GetUUIDError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::GetUUIDError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::GetUUIDError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "lookupIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::LookupIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::LookupIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::LookupIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::LookupIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::LookupIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::LookupIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "lookupAndTraverse",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::graph_storage_service::LookupAndTraverseExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::graph_storage_service::LookupAndTraverseExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::graph_storage_service::LookupAndTraverseExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::graph_storage_service::LookupAndTraverseError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::graph_storage_service::LookupAndTraverseError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::graph_storage_service::LookupAndTraverseError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> GraphStorageService for T
    where
        T: ::std::convert::AsRef<dyn GraphStorageService + 'a>,
        T: ::std::marker::Send,
    {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getNeighbors(
                arg_req,
            )
        }
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getProps(
                arg_req,
            )
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addVertices(
                arg_req,
            )
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addEdges(
                arg_req,
            )
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().deleteEdges(
                arg_req,
            )
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().deleteVertices(
                arg_req,
            )
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().updateVertex(
                arg_req,
            )
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().updateEdge(
                arg_req,
            )
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getUUID(
                arg_req,
            )
        }
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().lookupIndex(
                arg_req,
            )
        }
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> + ::std::marker::Send + 'static>> {
            self.as_ref().lookupAndTraverse(
                arg_req,
            )
        }
    }

    pub struct make_GraphStorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn GraphStorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl GraphStorageService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(GraphStorageServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_GraphStorageService {
        type Api = dyn GraphStorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            GraphStorageService::new(protocol, transport)
        }
    }
    pub struct StorageAdminServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> StorageAdminServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait StorageAdminService: ::std::marker::Send {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> + ::std::marker::Send + 'static>>;
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> + ::std::marker::Send + 'static>>;
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> + ::std::marker::Send + 'static>>;
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> + ::std::marker::Send + 'static>>;
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> + ::std::marker::Send + 'static>>;
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>>;
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CreateCheckpointError>> + ::std::marker::Send + 'static>>;
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> + ::std::marker::Send + 'static>>;
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> + ::std::marker::Send + 'static>>;
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>>;
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>>;
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> + ::std::marker::Send + 'static>>;
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> + ::std::marker::Send + 'static>>;
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> + ::std::marker::Send + 'static>>;
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> StorageAdminService for StorageAdminServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "transLeader",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::TransLeaderExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::TransLeaderExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::TransLeaderExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::TransLeaderError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::TransLeaderError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::TransLeaderError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addPart",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::AddPartExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::AddPartExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::AddPartExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::AddPartError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::AddPartError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::AddPartError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addLearner",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::AddLearnerExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::AddLearnerExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::AddLearnerExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::AddLearnerError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::AddLearnerError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::AddLearnerError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removePart",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::RemovePartExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::RemovePartExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::RemovePartExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::RemovePartError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::RemovePartError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::RemovePartError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "memberChange",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::MemberChangeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::MemberChangeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::MemberChangeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::MemberChangeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::MemberChangeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::MemberChangeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "waitingForCatchUpData",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::WaitingForCatchUpDataExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::WaitingForCatchUpDataError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::WaitingForCatchUpDataError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::WaitingForCatchUpDataError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CreateCheckpointError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createCheckpoint",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CreateCheckpointError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::CreateCheckpointExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::CreateCheckpointExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::CreateCheckpointExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::CreateCheckpointError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::CreateCheckpointError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::CreateCheckpointError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropCheckpoint",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::DropCheckpointExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::DropCheckpointExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::DropCheckpointExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::DropCheckpointError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::DropCheckpointError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::DropCheckpointError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "blockingWrites",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::BlockingWritesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::BlockingWritesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::BlockingWritesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::BlockingWritesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::BlockingWritesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::BlockingWritesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::RebuildTagIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::RebuildTagIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::RebuildTagIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildTagIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildTagIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildTagIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::RebuildEdgeIndexExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::RebuildEdgeIndexExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::RebuildEdgeIndexExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildEdgeIndexError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildEdgeIndexError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::RebuildEdgeIndexError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getLeaderParts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::GetLeaderPartsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::GetLeaderPartsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::GetLeaderPartsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::GetLeaderPartsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::GetLeaderPartsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::GetLeaderPartsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "checkPeers",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::CheckPeersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::CheckPeersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::CheckPeersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::CheckPeersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::CheckPeersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::CheckPeersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addAdminTask",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::AddAdminTaskExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::AddAdminTaskExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::AddAdminTaskExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::AddAdminTaskError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::AddAdminTaskError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::AddAdminTaskError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "stopAdminTask",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::storage_admin_service::StopAdminTaskExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::storage_admin_service::StopAdminTaskExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::storage_admin_service::StopAdminTaskExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::storage_admin_service::StopAdminTaskError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::storage_admin_service::StopAdminTaskError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::storage_admin_service::StopAdminTaskError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> StorageAdminService for T
    where
        T: ::std::convert::AsRef<dyn StorageAdminService + 'a>,
        T: ::std::marker::Send,
    {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> + ::std::marker::Send + 'static>> {
            self.as_ref().transLeader(
                arg_req,
            )
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addPart(
                arg_req,
            )
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addLearner(
                arg_req,
            )
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removePart(
                arg_req,
            )
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().memberChange(
                arg_req,
            )
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>> {
            self.as_ref().waitingForCatchUpData(
                arg_req,
            )
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CreateCheckpointError>> + ::std::marker::Send + 'static>> {
            self.as_ref().createCheckpoint(
                arg_req,
            )
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> + ::std::marker::Send + 'static>> {
            self.as_ref().dropCheckpoint(
                arg_req,
            )
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().blockingWrites(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getLeaderParts(
                arg_req,
            )
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().checkPeers(
                arg_req,
            )
        }
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addAdminTask(
                arg_req,
            )
        }
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> + ::std::marker::Send + 'static>> {
            self.as_ref().stopAdminTask(
                arg_req,
            )
        }
    }

    pub struct make_StorageAdminService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn StorageAdminService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl StorageAdminService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(StorageAdminServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_StorageAdminService {
        type Api = dyn StorageAdminService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            StorageAdminService::new(protocol, transport)
        }
    }
    pub struct GeneralStorageServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> GeneralStorageServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait GeneralStorageService: ::std::marker::Send {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> + ::std::marker::Send + 'static>>;
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> + ::std::marker::Send + 'static>>;
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> GeneralStorageService for GeneralStorageServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::general_storage_service::GetExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::general_storage_service::GetExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::general_storage_service::GetExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::general_storage_service::GetError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::general_storage_service::GetError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::general_storage_service::GetError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "put",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::general_storage_service::PutExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::general_storage_service::PutExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::general_storage_service::PutExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::general_storage_service::PutError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::general_storage_service::PutError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::general_storage_service::PutError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_req", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_req, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::general_storage_service::RemoveExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::general_storage_service::RemoveExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::general_storage_service::RemoveExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::general_storage_service::RemoveError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::general_storage_service::RemoveError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::general_storage_service::RemoveError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> GeneralStorageService for T
    where
        T: ::std::convert::AsRef<dyn GeneralStorageService + 'a>,
        T: ::std::marker::Send,
    {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> + ::std::marker::Send + 'static>> {
            self.as_ref().get(
                arg_req,
            )
        }
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> + ::std::marker::Send + 'static>> {
            self.as_ref().put(
                arg_req,
            )
        }
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> + ::std::marker::Send + 'static>> {
            self.as_ref().remove(
                arg_req,
            )
        }
    }

    pub struct make_GeneralStorageService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn GeneralStorageService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl GeneralStorageService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(GeneralStorageServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_GeneralStorageService {
        type Api = dyn GeneralStorageService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            GeneralStorageService::new(protocol, transport)
        }
    }
}

pub mod server {
    #[::async_trait::async_trait]
    pub trait GraphStorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn getNeighbors(
            &self,
            _req: crate::types::GetNeighborsRequest,
        ) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::services::graph_storage_service::GetNeighborsExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::GetNeighborsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "getNeighbors",
                ),
            ))
        }
        async fn getProps(
            &self,
            _req: crate::types::GetPropRequest,
        ) -> ::std::result::Result<crate::types::GetPropResponse, crate::services::graph_storage_service::GetPropsExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::GetPropsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "getProps",
                ),
            ))
        }
        async fn addVertices(
            &self,
            _req: crate::types::AddVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::AddVerticesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::AddVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "addVertices",
                ),
            ))
        }
        async fn addEdges(
            &self,
            _req: crate::types::AddEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::AddEdgesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::AddEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "addEdges",
                ),
            ))
        }
        async fn deleteEdges(
            &self,
            _req: crate::types::DeleteEdgesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteEdgesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::DeleteEdgesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "deleteEdges",
                ),
            ))
        }
        async fn deleteVertices(
            &self,
            _req: crate::types::DeleteVerticesRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::graph_storage_service::DeleteVerticesExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::DeleteVerticesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "deleteVertices",
                ),
            ))
        }
        async fn updateVertex(
            &self,
            _req: crate::types::UpdateVertexRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::UpdateVertexExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::UpdateVertexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "updateVertex",
                ),
            ))
        }
        async fn updateEdge(
            &self,
            _req: crate::types::UpdateEdgeRequest,
        ) -> ::std::result::Result<crate::types::UpdateResponse, crate::services::graph_storage_service::UpdateEdgeExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::UpdateEdgeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "updateEdge",
                ),
            ))
        }
        async fn getUUID(
            &self,
            _req: crate::types::GetUUIDReq,
        ) -> ::std::result::Result<crate::types::GetUUIDResp, crate::services::graph_storage_service::GetUUIDExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::GetUUIDExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "getUUID",
                ),
            ))
        }
        async fn lookupIndex(
            &self,
            _req: crate::types::LookupIndexRequest,
        ) -> ::std::result::Result<crate::types::LookupIndexResp, crate::services::graph_storage_service::LookupIndexExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::LookupIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "lookupIndex",
                ),
            ))
        }
        async fn lookupAndTraverse(
            &self,
            _req: crate::types::LookupAndTraverseRequest,
        ) -> ::std::result::Result<crate::types::GetNeighborsResponse, crate::services::graph_storage_service::LookupAndTraverseExn> {
            ::std::result::Result::Err(crate::services::graph_storage_service::LookupAndTraverseExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GraphStorageService",
                    "lookupAndTraverse",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct GraphStorageServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> GraphStorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GraphStorageService,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_getNeighbors<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getNeighbors(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getNeighbors",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::GetNeighborsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::GetNeighborsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::GetNeighborsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getNeighbors",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getNeighbors",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getProps<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getProps(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getProps",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::GetPropsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::GetPropsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::GetPropsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getProps",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getProps",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addVertices(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addVertices",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::AddVerticesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::AddVerticesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::AddVerticesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addVertices",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addVertices",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addEdges(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addEdges",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::AddEdgesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::AddEdgesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::AddEdgesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addEdges",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addEdges",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_deleteEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.deleteEdges(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "deleteEdges",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::DeleteEdgesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::DeleteEdgesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::DeleteEdgesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteEdges",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteEdges",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_deleteVertices<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.deleteVertices(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "deleteVertices",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::DeleteVerticesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::DeleteVerticesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::DeleteVerticesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "deleteVertices",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "deleteVertices",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_updateVertex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.updateVertex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "updateVertex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::UpdateVertexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::UpdateVertexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::UpdateVertexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateVertex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateVertex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_updateEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.updateEdge(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "updateEdge",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::UpdateEdgeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::UpdateEdgeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::UpdateEdgeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateEdge",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "updateEdge",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getUUID<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getUUID(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getUUID",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::GetUUIDExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::GetUUIDExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::GetUUIDExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUUID",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getUUID",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_lookupIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.lookupIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "lookupIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::LookupIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::LookupIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::LookupIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "lookupIndex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "lookupIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_lookupAndTraverse<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.lookupAndTraverse(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "lookupAndTraverse",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::graph_storage_service::LookupAndTraverseExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::LookupAndTraverseExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::graph_storage_service::LookupAndTraverseExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "lookupAndTraverse",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "lookupAndTraverse",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for GraphStorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GraphStorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"getNeighbors" => ::std::result::Result::Ok(0usize),
                b"getProps" => ::std::result::Result::Ok(1usize),
                b"addVertices" => ::std::result::Result::Ok(2usize),
                b"addEdges" => ::std::result::Result::Ok(3usize),
                b"deleteEdges" => ::std::result::Result::Ok(4usize),
                b"deleteVertices" => ::std::result::Result::Ok(5usize),
                b"updateVertex" => ::std::result::Result::Ok(6usize),
                b"updateEdge" => ::std::result::Result::Ok(7usize),
                b"getUUID" => ::std::result::Result::Ok(8usize),
                b"lookupIndex" => ::std::result::Result::Ok(9usize),
                b"lookupAndTraverse" => ::std::result::Result::Ok(10usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_getNeighbors(_p, _r, _seqid).await,
                1usize => self.handle_getProps(_p, _r, _seqid).await,
                2usize => self.handle_addVertices(_p, _r, _seqid).await,
                3usize => self.handle_addEdges(_p, _r, _seqid).await,
                4usize => self.handle_deleteEdges(_p, _r, _seqid).await,
                5usize => self.handle_deleteVertices(_p, _r, _seqid).await,
                6usize => self.handle_updateVertex(_p, _r, _seqid).await,
                7usize => self.handle_updateEdge(_p, _r, _seqid).await,
                8usize => self.handle_getUUID(_p, _r, _seqid).await,
                9usize => self.handle_lookupIndex(_p, _r, _seqid).await,
                10usize => self.handle_lookupAndTraverse(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "GraphStorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for GraphStorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: GraphStorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "GraphStorageServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_GraphStorageService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: GraphStorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GraphStorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GraphStorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
    #[::async_trait::async_trait]
    pub trait StorageAdminService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn transLeader(
            &self,
            _req: crate::types::TransLeaderReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::TransLeaderExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::TransLeaderExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "transLeader",
                ),
            ))
        }
        async fn addPart(
            &self,
            _req: crate::types::AddPartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddPartExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::AddPartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "addPart",
                ),
            ))
        }
        async fn addLearner(
            &self,
            _req: crate::types::AddLearnerReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddLearnerExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::AddLearnerExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "addLearner",
                ),
            ))
        }
        async fn removePart(
            &self,
            _req: crate::types::RemovePartReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RemovePartExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::RemovePartExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "removePart",
                ),
            ))
        }
        async fn memberChange(
            &self,
            _req: crate::types::MemberChangeReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::MemberChangeExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::MemberChangeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "memberChange",
                ),
            ))
        }
        async fn waitingForCatchUpData(
            &self,
            _req: crate::types::CatchUpDataReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::WaitingForCatchUpDataExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::WaitingForCatchUpDataExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "waitingForCatchUpData",
                ),
            ))
        }
        async fn createCheckpoint(
            &self,
            _req: crate::types::CreateCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::CreateCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::CreateCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "createCheckpoint",
                ),
            ))
        }
        async fn dropCheckpoint(
            &self,
            _req: crate::types::DropCPRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::DropCheckpointExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::DropCheckpointExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "dropCheckpoint",
                ),
            ))
        }
        async fn blockingWrites(
            &self,
            _req: crate::types::BlockingSignRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::BlockingWritesExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::BlockingWritesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "blockingWrites",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::RebuildTagIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::types::RebuildIndexRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::RebuildEdgeIndexExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn getLeaderParts(
            &self,
            _req: crate::types::GetLeaderReq,
        ) -> ::std::result::Result<crate::types::GetLeaderPartsResp, crate::services::storage_admin_service::GetLeaderPartsExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::GetLeaderPartsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "getLeaderParts",
                ),
            ))
        }
        async fn checkPeers(
            &self,
            _req: crate::types::CheckPeersReq,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::CheckPeersExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::CheckPeersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "checkPeers",
                ),
            ))
        }
        async fn addAdminTask(
            &self,
            _req: crate::types::AddAdminTaskRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::AddAdminTaskExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::AddAdminTaskExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "addAdminTask",
                ),
            ))
        }
        async fn stopAdminTask(
            &self,
            _req: crate::types::StopAdminTaskRequest,
        ) -> ::std::result::Result<crate::types::AdminExecResp, crate::services::storage_admin_service::StopAdminTaskExn> {
            ::std::result::Result::Err(crate::services::storage_admin_service::StopAdminTaskExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "StorageAdminService",
                    "stopAdminTask",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct StorageAdminServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> StorageAdminServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageAdminService,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_transLeader<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.transLeader(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "transLeader",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::TransLeaderExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::TransLeaderExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::TransLeaderExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "transLeader",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "transLeader",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addPart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addPart(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addPart",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::AddPartExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::AddPartExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::AddPartExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addPart",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addPart",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addLearner<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addLearner(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addLearner",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::AddLearnerExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::AddLearnerExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::AddLearnerExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addLearner",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addLearner",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_removePart<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removePart(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removePart",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::RemovePartExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::RemovePartExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::RemovePartExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removePart",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removePart",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_memberChange<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.memberChange(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "memberChange",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::MemberChangeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::MemberChangeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::MemberChangeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "memberChange",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "memberChange",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_waitingForCatchUpData<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.waitingForCatchUpData(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "waitingForCatchUpData",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::WaitingForCatchUpDataExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::WaitingForCatchUpDataExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::WaitingForCatchUpDataExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "waitingForCatchUpData",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "waitingForCatchUpData",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_createCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.createCheckpoint(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "createCheckpoint",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::CreateCheckpointExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::CreateCheckpointExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::CreateCheckpointExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createCheckpoint",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "createCheckpoint",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_dropCheckpoint<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.dropCheckpoint(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "dropCheckpoint",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::DropCheckpointExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::DropCheckpointExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::DropCheckpointExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropCheckpoint",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "dropCheckpoint",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_blockingWrites<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.blockingWrites(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "blockingWrites",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::BlockingWritesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::BlockingWritesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::BlockingWritesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "blockingWrites",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "blockingWrites",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.rebuildTagIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildTagIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::RebuildTagIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::RebuildTagIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildTagIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.rebuildEdgeIndex(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "rebuildEdgeIndex",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::RebuildEdgeIndexExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::RebuildEdgeIndexExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "rebuildEdgeIndex",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getLeaderParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getLeaderParts(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getLeaderParts",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::GetLeaderPartsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::GetLeaderPartsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::GetLeaderPartsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getLeaderParts",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getLeaderParts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_checkPeers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.checkPeers(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "checkPeers",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::CheckPeersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::CheckPeersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::CheckPeersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "checkPeers",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "checkPeers",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addAdminTask<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addAdminTask(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addAdminTask",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::AddAdminTaskExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::AddAdminTaskExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::AddAdminTaskExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addAdminTask",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addAdminTask",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_stopAdminTask<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.stopAdminTask(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "stopAdminTask",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::storage_admin_service::StopAdminTaskExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::StopAdminTaskExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::storage_admin_service::StopAdminTaskExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "stopAdminTask",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "stopAdminTask",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for StorageAdminServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: StorageAdminService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"transLeader" => ::std::result::Result::Ok(0usize),
                b"addPart" => ::std::result::Result::Ok(1usize),
                b"addLearner" => ::std::result::Result::Ok(2usize),
                b"removePart" => ::std::result::Result::Ok(3usize),
                b"memberChange" => ::std::result::Result::Ok(4usize),
                b"waitingForCatchUpData" => ::std::result::Result::Ok(5usize),
                b"createCheckpoint" => ::std::result::Result::Ok(6usize),
                b"dropCheckpoint" => ::std::result::Result::Ok(7usize),
                b"blockingWrites" => ::std::result::Result::Ok(8usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(9usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(10usize),
                b"getLeaderParts" => ::std::result::Result::Ok(11usize),
                b"checkPeers" => ::std::result::Result::Ok(12usize),
                b"addAdminTask" => ::std::result::Result::Ok(13usize),
                b"stopAdminTask" => ::std::result::Result::Ok(14usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_transLeader(_p, _r, _seqid).await,
                1usize => self.handle_addPart(_p, _r, _seqid).await,
                2usize => self.handle_addLearner(_p, _r, _seqid).await,
                3usize => self.handle_removePart(_p, _r, _seqid).await,
                4usize => self.handle_memberChange(_p, _r, _seqid).await,
                5usize => self.handle_waitingForCatchUpData(_p, _r, _seqid).await,
                6usize => self.handle_createCheckpoint(_p, _r, _seqid).await,
                7usize => self.handle_dropCheckpoint(_p, _r, _seqid).await,
                8usize => self.handle_blockingWrites(_p, _r, _seqid).await,
                9usize => self.handle_rebuildTagIndex(_p, _r, _seqid).await,
                10usize => self.handle_rebuildEdgeIndex(_p, _r, _seqid).await,
                11usize => self.handle_getLeaderParts(_p, _r, _seqid).await,
                12usize => self.handle_checkPeers(_p, _r, _seqid).await,
                13usize => self.handle_addAdminTask(_p, _r, _seqid).await,
                14usize => self.handle_stopAdminTask(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "StorageAdminServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for StorageAdminServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: StorageAdminService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "StorageAdminServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_StorageAdminService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: StorageAdminService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageAdminServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(StorageAdminServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
    #[::async_trait::async_trait]
    pub trait GeneralStorageService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn get(
            &self,
            _req: crate::types::KVGetRequest,
        ) -> ::std::result::Result<crate::types::KVGetResponse, crate::services::general_storage_service::GetExn> {
            ::std::result::Result::Err(crate::services::general_storage_service::GetExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GeneralStorageService",
                    "get",
                ),
            ))
        }
        async fn put(
            &self,
            _req: crate::types::KVPutRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::general_storage_service::PutExn> {
            ::std::result::Result::Err(crate::services::general_storage_service::PutExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GeneralStorageService",
                    "put",
                ),
            ))
        }
        async fn remove(
            &self,
            _req: crate::types::KVRemoveRequest,
        ) -> ::std::result::Result<crate::types::ExecResponse, crate::services::general_storage_service::RemoveExn> {
            ::std::result::Result::Err(crate::services::general_storage_service::RemoveExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "GeneralStorageService",
                    "remove",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct GeneralStorageServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> GeneralStorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GeneralStorageService,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_get<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.get(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "get",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::general_storage_service::GetExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::general_storage_service::GetExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::general_storage_service::GetExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "get",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "get",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_put<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.put(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "put",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::general_storage_service::PutExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::general_storage_service::PutExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::general_storage_service::PutExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "put",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "put",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_remove<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.remove(
                field_req.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "remove",
                        "req",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::general_storage_service::RemoveExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::general_storage_service::RemoveExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::general_storage_service::RemoveExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "remove",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "remove",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for GeneralStorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: GeneralStorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"get" => ::std::result::Result::Ok(0usize),
                b"put" => ::std::result::Result::Ok(1usize),
                b"remove" => ::std::result::Result::Ok(2usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_get(_p, _r, _seqid).await,
                1usize => self.handle_put(_p, _r, _seqid).await,
                2usize => self.handle_remove(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "GeneralStorageServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for GeneralStorageServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: GeneralStorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "GeneralStorageServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_GeneralStorageService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: GeneralStorageService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GeneralStorageServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(GeneralStorageServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
///     service MyService {
///         FunctionResponse myFunction(
///             1: FunctionRequest request,
///         ) throws {
///             1: StorageException s,
///             2: NotFoundException n,
///         ),
///
///         // other functions
///     }
///
///
/// we would end up with this mock object under crate::mock::MyService:
///
///     impl crate::client::MyService for MyService<'mock> {...}
///
///     pub struct MyService<'mock> {
///         pub myFunction: myFunction<'mock>,
///         // ...
///     }
///
///     impl dyn crate::client::MyService {
///         pub fn mock<'mock>() -> MyService<'mock>;
///     }
///
///     impl myFunction<'mock> {
///         // directly return the given success response
///         pub fn ret(&self, value: FunctionResponse);
///
///         // invoke closure to compute success response
///         pub fn mock(
///             &self,
///             mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///         );
///
///         // return one of the function's declared exceptions
///         pub fn throw<E>(&self, exception: E)
///         where
///             E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
///     }
///
///     impl From<StorageException> for MyFunctionExn {...}
///     impl From<NotFoundException> for MyFunctionExn {...}
///
///
/// The intended usage from a test would be:
///
///     use std::sync::Arc;
///     use thrift_if::client::MyService;
///
///     #[test]
///     fn test_my_client() {
///         let mock = Arc::new(MyService::mock());
///
///         // directly return a success response
///         let resp = FunctionResponse {...};
///         mock.myFunction.ret(resp);
///
///         // or give a closure to compute the success response
///         mock.myFunction.mock(|request| FunctionResponse {...});
///
///         // or throw one of the function's exceptions
///         mock.myFunction.throw(StorageException::ItFailed);
///
///         let out = do_the_thing(mock).wait().unwrap();
///         assert!(out.what_i_expected());
///     }
///
///     fn do_the_thing(
///         client: Arc<dyn MyService + Send + Sync + 'static>,
///     ) -> impl Future<Item = Out> {...}
pub mod mock {
    pub struct GraphStorageService<'mock> {
        pub getNeighbors: r#impl::graph_storage_service::getNeighbors<'mock>,
        pub getProps: r#impl::graph_storage_service::getProps<'mock>,
        pub addVertices: r#impl::graph_storage_service::addVertices<'mock>,
        pub addEdges: r#impl::graph_storage_service::addEdges<'mock>,
        pub deleteEdges: r#impl::graph_storage_service::deleteEdges<'mock>,
        pub deleteVertices: r#impl::graph_storage_service::deleteVertices<'mock>,
        pub updateVertex: r#impl::graph_storage_service::updateVertex<'mock>,
        pub updateEdge: r#impl::graph_storage_service::updateEdge<'mock>,
        pub getUUID: r#impl::graph_storage_service::getUUID<'mock>,
        pub lookupIndex: r#impl::graph_storage_service::lookupIndex<'mock>,
        pub lookupAndTraverse: r#impl::graph_storage_service::lookupAndTraverse<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::GraphStorageService {
        pub fn mock<'mock>() -> GraphStorageService<'mock> {
            GraphStorageService {
                getNeighbors: r#impl::graph_storage_service::getNeighbors::unimplemented(),
                getProps: r#impl::graph_storage_service::getProps::unimplemented(),
                addVertices: r#impl::graph_storage_service::addVertices::unimplemented(),
                addEdges: r#impl::graph_storage_service::addEdges::unimplemented(),
                deleteEdges: r#impl::graph_storage_service::deleteEdges::unimplemented(),
                deleteVertices: r#impl::graph_storage_service::deleteVertices::unimplemented(),
                updateVertex: r#impl::graph_storage_service::updateVertex::unimplemented(),
                updateEdge: r#impl::graph_storage_service::updateEdge::unimplemented(),
                getUUID: r#impl::graph_storage_service::getUUID::unimplemented(),
                lookupIndex: r#impl::graph_storage_service::lookupIndex::unimplemented(),
                lookupAndTraverse: r#impl::graph_storage_service::lookupAndTraverse::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::GraphStorageService for GraphStorageService<'mock> {
        fn getNeighbors(
            &self,
            arg_req: &crate::types::GetNeighborsRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::GetNeighborsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getNeighbors.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getProps(
            &self,
            arg_req: &crate::types::GetPropRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetPropResponse, crate::errors::graph_storage_service::GetPropsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getProps.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetPropRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addVertices(
            &self,
            arg_req: &crate::types::AddVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddVerticesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addEdges(
            &self,
            arg_req: &crate::types::AddEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::AddEdgesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteEdges(
            &self,
            arg_req: &crate::types::DeleteEdgesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteEdgesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.deleteEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn deleteVertices(
            &self,
            arg_req: &crate::types::DeleteVerticesRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::graph_storage_service::DeleteVerticesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.deleteVertices.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateVertex(
            &self,
            arg_req: &crate::types::UpdateVertexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateVertexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.updateVertex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateEdge(
            &self,
            arg_req: &crate::types::UpdateEdgeRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::UpdateResponse, crate::errors::graph_storage_service::UpdateEdgeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.updateEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUUID(
            &self,
            arg_req: &crate::types::GetUUIDReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetUUIDResp, crate::errors::graph_storage_service::GetUUIDError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getUUID.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn lookupIndex(
            &self,
            arg_req: &crate::types::LookupIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::LookupIndexResp, crate::errors::graph_storage_service::LookupIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.lookupIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LookupIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn lookupAndTraverse(
            &self,
            arg_req: &crate::types::LookupAndTraverseRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetNeighborsResponse, crate::errors::graph_storage_service::LookupAndTraverseError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.lookupAndTraverse.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }


    pub struct StorageAdminService<'mock> {
        pub transLeader: r#impl::storage_admin_service::transLeader<'mock>,
        pub addPart: r#impl::storage_admin_service::addPart<'mock>,
        pub addLearner: r#impl::storage_admin_service::addLearner<'mock>,
        pub removePart: r#impl::storage_admin_service::removePart<'mock>,
        pub memberChange: r#impl::storage_admin_service::memberChange<'mock>,
        pub waitingForCatchUpData: r#impl::storage_admin_service::waitingForCatchUpData<'mock>,
        pub createCheckpoint: r#impl::storage_admin_service::createCheckpoint<'mock>,
        pub dropCheckpoint: r#impl::storage_admin_service::dropCheckpoint<'mock>,
        pub blockingWrites: r#impl::storage_admin_service::blockingWrites<'mock>,
        pub rebuildTagIndex: r#impl::storage_admin_service::rebuildTagIndex<'mock>,
        pub rebuildEdgeIndex: r#impl::storage_admin_service::rebuildEdgeIndex<'mock>,
        pub getLeaderParts: r#impl::storage_admin_service::getLeaderParts<'mock>,
        pub checkPeers: r#impl::storage_admin_service::checkPeers<'mock>,
        pub addAdminTask: r#impl::storage_admin_service::addAdminTask<'mock>,
        pub stopAdminTask: r#impl::storage_admin_service::stopAdminTask<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::StorageAdminService {
        pub fn mock<'mock>() -> StorageAdminService<'mock> {
            StorageAdminService {
                transLeader: r#impl::storage_admin_service::transLeader::unimplemented(),
                addPart: r#impl::storage_admin_service::addPart::unimplemented(),
                addLearner: r#impl::storage_admin_service::addLearner::unimplemented(),
                removePart: r#impl::storage_admin_service::removePart::unimplemented(),
                memberChange: r#impl::storage_admin_service::memberChange::unimplemented(),
                waitingForCatchUpData: r#impl::storage_admin_service::waitingForCatchUpData::unimplemented(),
                createCheckpoint: r#impl::storage_admin_service::createCheckpoint::unimplemented(),
                dropCheckpoint: r#impl::storage_admin_service::dropCheckpoint::unimplemented(),
                blockingWrites: r#impl::storage_admin_service::blockingWrites::unimplemented(),
                rebuildTagIndex: r#impl::storage_admin_service::rebuildTagIndex::unimplemented(),
                rebuildEdgeIndex: r#impl::storage_admin_service::rebuildEdgeIndex::unimplemented(),
                getLeaderParts: r#impl::storage_admin_service::getLeaderParts::unimplemented(),
                checkPeers: r#impl::storage_admin_service::checkPeers::unimplemented(),
                addAdminTask: r#impl::storage_admin_service::addAdminTask::unimplemented(),
                stopAdminTask: r#impl::storage_admin_service::stopAdminTask::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::StorageAdminService for StorageAdminService<'mock> {
        fn transLeader(
            &self,
            arg_req: &crate::types::TransLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::TransLeaderError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.transLeader.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addPart(
            &self,
            arg_req: &crate::types::AddPartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddPartError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addPart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddPartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addLearner(
            &self,
            arg_req: &crate::types::AddLearnerReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddLearnerError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addLearner.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removePart(
            &self,
            arg_req: &crate::types::RemovePartReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RemovePartError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removePart.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn memberChange(
            &self,
            arg_req: &crate::types::MemberChangeReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::MemberChangeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.memberChange.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn waitingForCatchUpData(
            &self,
            arg_req: &crate::types::CatchUpDataReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::WaitingForCatchUpDataError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.waitingForCatchUpData.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createCheckpoint(
            &self,
            arg_req: &crate::types::CreateCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CreateCheckpointError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.createCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropCheckpoint(
            &self,
            arg_req: &crate::types::DropCPRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::DropCheckpointError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.dropCheckpoint.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn blockingWrites(
            &self,
            arg_req: &crate::types::BlockingSignRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::BlockingWritesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.blockingWrites.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildTagIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::types::RebuildIndexRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::RebuildEdgeIndexError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getLeaderParts(
            &self,
            arg_req: &crate::types::GetLeaderReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetLeaderPartsResp, crate::errors::storage_admin_service::GetLeaderPartsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getLeaderParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn checkPeers(
            &self,
            arg_req: &crate::types::CheckPeersReq,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::CheckPeersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.checkPeers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addAdminTask(
            &self,
            arg_req: &crate::types::AddAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::AddAdminTaskError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addAdminTask.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn stopAdminTask(
            &self,
            arg_req: &crate::types::StopAdminTaskRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::AdminExecResp, crate::errors::storage_admin_service::StopAdminTaskError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.stopAdminTask.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }


    pub struct GeneralStorageService<'mock> {
        pub get: r#impl::general_storage_service::get<'mock>,
        pub put: r#impl::general_storage_service::put<'mock>,
        pub remove: r#impl::general_storage_service::remove<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::GeneralStorageService {
        pub fn mock<'mock>() -> GeneralStorageService<'mock> {
            GeneralStorageService {
                get: r#impl::general_storage_service::get::unimplemented(),
                put: r#impl::general_storage_service::put::unimplemented(),
                remove: r#impl::general_storage_service::remove::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::GeneralStorageService for GeneralStorageService<'mock> {
        fn get(
            &self,
            arg_req: &crate::types::KVGetRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::KVGetResponse, crate::errors::general_storage_service::GetError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.get.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KVGetRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn put(
            &self,
            arg_req: &crate::types::KVPutRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::PutError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.put.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KVPutRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn remove(
            &self,
            arg_req: &crate::types::KVRemoveRequest,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ExecResponse, crate::errors::general_storage_service::RemoveError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.remove.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::KVRemoveRequest) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod graph_storage_service {

            pub struct getNeighbors<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> ::std::result::Result<
                        crate::types::GetNeighborsResponse,
                        crate::errors::graph_storage_service::GetNeighborsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getNeighbors<'mock> {
                pub fn unimplemented() -> Self {
                    getNeighbors {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetNeighborsRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "getNeighbors",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetNeighborsResponse) {
                    self.mock(move |_: crate::types::GetNeighborsRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetNeighborsRequest) -> crate::types::GetNeighborsResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::GetNeighborsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetNeighborsRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getProps<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetPropRequest) -> ::std::result::Result<
                        crate::types::GetPropResponse,
                        crate::errors::graph_storage_service::GetPropsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getProps<'mock> {
                pub fn unimplemented() -> Self {
                    getProps {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetPropRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "getProps",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetPropResponse) {
                    self.mock(move |_: crate::types::GetPropRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetPropRequest) -> crate::types::GetPropResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::GetPropsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetPropRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::AddVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addVertices<'mock> {
                pub fn unimplemented() -> Self {
                    addVertices {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "addVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::AddVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::AddEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addEdges<'mock> {
                pub fn unimplemented() -> Self {
                    addEdges {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "addEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::AddEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::AddEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::DeleteEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> deleteEdges<'mock> {
                pub fn unimplemented() -> Self {
                    deleteEdges {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteEdgesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "deleteEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteEdgesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteEdgesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::DeleteEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteEdgesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct deleteVertices<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::graph_storage_service::DeleteVerticesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> deleteVertices<'mock> {
                pub fn unimplemented() -> Self {
                    deleteVertices {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DeleteVerticesRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "deleteVertices",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::DeleteVerticesRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DeleteVerticesRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::DeleteVerticesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DeleteVerticesRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateVertex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::graph_storage_service::UpdateVertexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> updateVertex<'mock> {
                pub fn unimplemented() -> Self {
                    updateVertex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateVertexRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "updateVertex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateVertexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateVertexRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::UpdateVertexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateVertexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> ::std::result::Result<
                        crate::types::UpdateResponse,
                        crate::errors::graph_storage_service::UpdateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> updateEdge<'mock> {
                pub fn unimplemented() -> Self {
                    updateEdge {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UpdateEdgeRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "updateEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::UpdateResponse) {
                    self.mock(move |_: crate::types::UpdateEdgeRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UpdateEdgeRequest) -> crate::types::UpdateResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::UpdateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UpdateEdgeRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUUID<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetUUIDReq) -> ::std::result::Result<
                        crate::types::GetUUIDResp,
                        crate::errors::graph_storage_service::GetUUIDError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getUUID<'mock> {
                pub fn unimplemented() -> Self {
                    getUUID {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetUUIDReq| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "getUUID",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetUUIDResp) {
                    self.mock(move |_: crate::types::GetUUIDReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetUUIDReq) -> crate::types::GetUUIDResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::GetUUIDError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetUUIDReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct lookupIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LookupIndexRequest) -> ::std::result::Result<
                        crate::types::LookupIndexResp,
                        crate::errors::graph_storage_service::LookupIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> lookupIndex<'mock> {
                pub fn unimplemented() -> Self {
                    lookupIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LookupIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "lookupIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::LookupIndexResp) {
                    self.mock(move |_: crate::types::LookupIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookupIndexRequest) -> crate::types::LookupIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::LookupIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LookupIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct lookupAndTraverse<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> ::std::result::Result<
                        crate::types::GetNeighborsResponse,
                        crate::errors::graph_storage_service::LookupAndTraverseError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> lookupAndTraverse<'mock> {
                pub fn unimplemented() -> Self {
                    lookupAndTraverse {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::LookupAndTraverseRequest| panic!(
                            "{}::{} is not mocked",
                            "GraphStorageService",
                            "lookupAndTraverse",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetNeighborsResponse) {
                    self.mock(move |_: crate::types::LookupAndTraverseRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::LookupAndTraverseRequest) -> crate::types::GetNeighborsResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::graph_storage_service::LookupAndTraverseError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::LookupAndTraverseRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
        pub mod storage_admin_service {

            pub struct transLeader<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::TransLeaderReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::TransLeaderError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> transLeader<'mock> {
                pub fn unimplemented() -> Self {
                    transLeader {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::TransLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "transLeader",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::TransLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::TransLeaderReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::TransLeaderError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::TransLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addPart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddPartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::AddPartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addPart<'mock> {
                pub fn unimplemented() -> Self {
                    addPart {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddPartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "addPart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddPartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddPartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::AddPartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddPartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addLearner<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddLearnerReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::AddLearnerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addLearner<'mock> {
                pub fn unimplemented() -> Self {
                    addLearner {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddLearnerReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "addLearner",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddLearnerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddLearnerReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::AddLearnerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddLearnerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removePart<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemovePartReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::RemovePartError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removePart<'mock> {
                pub fn unimplemented() -> Self {
                    removePart {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemovePartReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "removePart",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RemovePartReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemovePartReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::RemovePartError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemovePartReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct memberChange<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MemberChangeReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::MemberChangeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> memberChange<'mock> {
                pub fn unimplemented() -> Self {
                    memberChange {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MemberChangeReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "memberChange",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::MemberChangeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MemberChangeReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::MemberChangeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MemberChangeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct waitingForCatchUpData<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CatchUpDataReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::WaitingForCatchUpDataError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> waitingForCatchUpData<'mock> {
                pub fn unimplemented() -> Self {
                    waitingForCatchUpData {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CatchUpDataReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "waitingForCatchUpData",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CatchUpDataReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CatchUpDataReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::WaitingForCatchUpDataError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CatchUpDataReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CreateCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::CreateCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> createCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    createCheckpoint {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CreateCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "createCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CreateCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CreateCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::CreateCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CreateCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropCheckpoint<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DropCPRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::DropCheckpointError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> dropCheckpoint<'mock> {
                pub fn unimplemented() -> Self {
                    dropCheckpoint {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DropCPRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "dropCheckpoint",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::DropCPRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DropCPRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::DropCheckpointError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DropCPRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct blockingWrites<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::BlockingSignRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::BlockingWritesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> blockingWrites<'mock> {
                pub fn unimplemented() -> Self {
                    blockingWrites {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::BlockingSignRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "blockingWrites",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::BlockingSignRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::BlockingSignRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::BlockingWritesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::BlockingSignRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildTagIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    rebuildEdgeIndex {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RebuildIndexRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::RebuildIndexRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RebuildIndexRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RebuildIndexRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getLeaderParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetLeaderReq) -> ::std::result::Result<
                        crate::types::GetLeaderPartsResp,
                        crate::errors::storage_admin_service::GetLeaderPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getLeaderParts<'mock> {
                pub fn unimplemented() -> Self {
                    getLeaderParts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetLeaderReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "getLeaderParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetLeaderPartsResp) {
                    self.mock(move |_: crate::types::GetLeaderReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetLeaderReq) -> crate::types::GetLeaderPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::GetLeaderPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetLeaderReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkPeers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::CheckPeersReq) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::CheckPeersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> checkPeers<'mock> {
                pub fn unimplemented() -> Self {
                    checkPeers {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::CheckPeersReq| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "checkPeers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::CheckPeersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::CheckPeersReq) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::CheckPeersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::CheckPeersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addAdminTask<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::AddAdminTaskError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addAdminTask<'mock> {
                pub fn unimplemented() -> Self {
                    addAdminTask {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::AddAdminTaskRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "addAdminTask",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::AddAdminTaskRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::AddAdminTaskRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::AddAdminTaskError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::AddAdminTaskRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct stopAdminTask<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> ::std::result::Result<
                        crate::types::AdminExecResp,
                        crate::errors::storage_admin_service::StopAdminTaskError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> stopAdminTask<'mock> {
                pub fn unimplemented() -> Self {
                    stopAdminTask {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::StopAdminTaskRequest| panic!(
                            "{}::{} is not mocked",
                            "StorageAdminService",
                            "stopAdminTask",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::AdminExecResp) {
                    self.mock(move |_: crate::types::StopAdminTaskRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::StopAdminTaskRequest) -> crate::types::AdminExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::storage_admin_service::StopAdminTaskError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::StopAdminTaskRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
        pub mod general_storage_service {

            pub struct get<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KVGetRequest) -> ::std::result::Result<
                        crate::types::KVGetResponse,
                        crate::errors::general_storage_service::GetError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> get<'mock> {
                pub fn unimplemented() -> Self {
                    get {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KVGetRequest| panic!(
                            "{}::{} is not mocked",
                            "GeneralStorageService",
                            "get",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::KVGetResponse) {
                    self.mock(move |_: crate::types::KVGetRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVGetRequest) -> crate::types::KVGetResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::general_storage_service::GetError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KVGetRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct put<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KVPutRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::general_storage_service::PutError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> put<'mock> {
                pub fn unimplemented() -> Self {
                    put {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KVPutRequest| panic!(
                            "{}::{} is not mocked",
                            "GeneralStorageService",
                            "put",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::KVPutRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVPutRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::general_storage_service::PutError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KVPutRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct remove<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::KVRemoveRequest) -> ::std::result::Result<
                        crate::types::ExecResponse,
                        crate::errors::general_storage_service::RemoveError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> remove<'mock> {
                pub fn unimplemented() -> Self {
                    remove {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::KVRemoveRequest| panic!(
                            "{}::{} is not mocked",
                            "GeneralStorageService",
                            "remove",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ExecResponse) {
                    self.mock(move |_: crate::types::KVRemoveRequest| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::KVRemoveRequest) -> crate::types::ExecResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::general_storage_service::RemoveError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::KVRemoveRequest| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

pub mod errors {
    pub mod graph_storage_service {

        pub type GetNeighborsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetPropsError = ::fbthrift::NonthrowingFunctionError;

        pub type AddVerticesError = ::fbthrift::NonthrowingFunctionError;

        pub type AddEdgesError = ::fbthrift::NonthrowingFunctionError;

        pub type DeleteEdgesError = ::fbthrift::NonthrowingFunctionError;

        pub type DeleteVerticesError = ::fbthrift::NonthrowingFunctionError;

        pub type UpdateVertexError = ::fbthrift::NonthrowingFunctionError;

        pub type UpdateEdgeError = ::fbthrift::NonthrowingFunctionError;

        pub type GetUUIDError = ::fbthrift::NonthrowingFunctionError;

        pub type LookupIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type LookupAndTraverseError = ::fbthrift::NonthrowingFunctionError;

    }

    pub mod storage_admin_service {

        pub type TransLeaderError = ::fbthrift::NonthrowingFunctionError;

        pub type AddPartError = ::fbthrift::NonthrowingFunctionError;

        pub type AddLearnerError = ::fbthrift::NonthrowingFunctionError;

        pub type RemovePartError = ::fbthrift::NonthrowingFunctionError;

        pub type MemberChangeError = ::fbthrift::NonthrowingFunctionError;

        pub type WaitingForCatchUpDataError = ::fbthrift::NonthrowingFunctionError;

        pub type CreateCheckpointError = ::fbthrift::NonthrowingFunctionError;

        pub type DropCheckpointError = ::fbthrift::NonthrowingFunctionError;

        pub type BlockingWritesError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildTagIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type RebuildEdgeIndexError = ::fbthrift::NonthrowingFunctionError;

        pub type GetLeaderPartsError = ::fbthrift::NonthrowingFunctionError;

        pub type CheckPeersError = ::fbthrift::NonthrowingFunctionError;

        pub type AddAdminTaskError = ::fbthrift::NonthrowingFunctionError;

        pub type StopAdminTaskError = ::fbthrift::NonthrowingFunctionError;

    }

    pub mod general_storage_service {

        pub type GetError = ::fbthrift::NonthrowingFunctionError;

        pub type PutError = ::fbthrift::NonthrowingFunctionError;

        pub type RemoveError = ::fbthrift::NonthrowingFunctionError;

    }

}
